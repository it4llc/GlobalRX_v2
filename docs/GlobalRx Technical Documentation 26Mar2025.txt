GlobalRx Technical DocumentationTable of Contents1. Technical Stack and Architecture2. Project Structure3. UI Standards and Styling4. Dialog Implementation Standards5. Form Standards6. Table Standards7. Translation System8. Module Documentation9. Development Workflow# Technical Stack and Architecture## Technology Stack### Language and Core- **Language**: TypeScript- **Package Manager**: pnpm  - Faster installation  - Disk space efficient  - Better dependency management### Frontend- **Framework**: Next.js 14 with TypeScript  - App Router  - Strong type safety across the application  - Server-side rendering for better performance  - Built-in API routes- **UI Components**:   - Tailwind CSS for styling  - Shadcn/ui for pre-built components  - Native HTML `<dialog>` element for all modal dialogs  - React Hook Form for form handling  - Zod for form validation and type inference### Backend- **API**: Next.js API routes with TypeScript  - Type-safe API endpoints  - Request/Response type validation- **Database**: PostgreSQL  - Robust relational database for structured data  - Strong data integrity features  - Type-safe queries via Prisma- **ORM**: Prisma  - Type-safe database queries  - Auto-generated TypeScript types from schema  - Excellent migration support### Authentication- **NextAuth.js**  - Session management  - Role-based access control  - Secure password hashing  - BCryptJS for password encryption### Development Tools- **Version Control**: Git- **Package Manager**: pnpm- **Code Quality**:   - ESLint with TypeScript support  - Prettier  - TypeScript strict mode enabled## Architecture Overview### Modular ArchitectureThe GlobalRx platform is built with a modular architecture, with four core modules:1. **User Admin**: Create, edit, and disable internal users2. **Global Configurations**: Global settings for locations, services, DSX, and translations3. **Customer Configurations**: Customer-specific information and service scopes4. **Candidate Workflow**: Application forms and multilingual supportEach module is independent and communicates with others via APIs when necessary.### Communication Flow- Client-side components communicate with backend via API routes- API routes handle business logic and database interactions- Prisma ORM manages database queries with type safety- Authentication is managed through NextAuth.js### Implementation Phases#### Phase 1: Foundation (Completed)- Project setup with TypeScript and Next.js 14- Basic UI components with Shadcn/ui- Style guide creation- User authentication system setup- Initial User admin module#### Phase 2: Global Configurations (Current Phase)1. Locations management   - Country table implementation   - Region/subregion management2. Services configuration   - Service definition and management3. DSX implementation   - Data fields and documents requirements4. Translations management   - Language support for UI elements#### Phase 3: Customer Configurations (Upcoming)1. Customer management   - Customer account creation and editing   - Invoice settings2. Customer scope implementation   - Service package configuration   - Customer-specific service settings#### Phase 4: Candidate Workflow (Future)1. Application form creation2. Multilingual support3. Workflow management## Technical Decisions### Dialog Implementation- The application uses native HTML `<dialog>` elements instead of Shadcn UI Dialog components- This approach provides better performance, reliability, and browser compatibility- A standardized ModalDialog component ensures consistency across the application### Translation System- JSON-based translation files for each supported language- Context-based translation delivery via TranslationContext- Support for both client and server components- UI for managing translations in the Global Configurations module### Form Layout- Consistent table-based layout with right-aligned labels- Standardized styling for all form elements- Fixed heights for input elements to ensure consistent appearance### Data Tables- Consistent table layouts with fixed column widths- Standardized action dropdown component- Pagination and filter controls### Authentication- Role-based permission system- Server-side session validation- Secure login and session management# Project Structure## Directory Organization```GlobalRx/??? prisma/?   ??? schema.prisma     # Database schema definition?   ??? seed.js           # Database seeding scripts?   ??? simple-seed.js??? public/?   ??? assets/           # Static assets (images, etc.)?   ??? file.svg?   ??? globe.svg?   ??? other SVG files??? src/?   ??? app/              # App Router pages and routes?   ?   ??? admin/?   ?   ?   ??? users/    # User administration?   ?   ??? api/          # API routes?   ?   ?   ??? auth/?   ?   ?   ?   ??? [...nextauth]/?   ?   ?   ??? users/?   ?   ?   ??? services/?   ?   ?   ??? locations/?   ?   ?   ??? translations/?   ?   ??? login/        # Login page?   ?   ??? style-guide/  # Style guide page?   ?   ??? globals.css   # Global styles?   ?   ??? layout.tsx    # Root layout?   ?   ??? page.tsx      # Home page?   ??? components/?   ?   ??? auth/         # Authentication components?   ?   ??? layout/       # Layout components?   ?   ?   ??? main-nav.tsx           # Main navigation?   ?   ?   ??? page-content.tsx       # Page content wrapper?   ?   ?   ??? content-section.tsx    # Content section component?   ?   ??? modules/      # Module-specific components?   ?   ?   ??? user-admin/            # User admin components?   ?   ?   ??? global-config/         # Global config components?   ?   ?   ?   ??? tabs/              # Tab components?   ?   ?   ?   ?   ??? locations-tab.tsx?   ?   ?   ?   ?   ??? services-tab.tsx?   ?   ?   ?   ?   ??? dsx-tab.tsx?   ?   ?   ?   ?   ??? translations-tab.tsx?   ?   ?   ?   ??? locations/         # Location-specific components?   ?   ?   ?   ??? services/          # Service-specific components?   ?   ?   ?   ??? dsx/               # DSX-specific components?   ?   ?   ??? translations/          # Translation components?   ?   ?   ??? customer/              # Customer components?   ?   ??? style-guide/  # Style guide components?   ?   ??? ui/           # UI components?   ?       ??? action-dropdown.tsx    # Action dropdown component?   ?       ??? alert-dialog.tsx       # Alert dialog component?   ?       ??? button.tsx             # Button component?   ?       ??? card.tsx               # Card component?   ?       ??? checkbox.tsx           # Checkbox component?   ?       ??? dialog-polyfill.tsx    # Dialog polyfill component?   ?       ??? form.tsx               # Form components?   ?       ??? input.tsx              # Input component?   ?       ??? label.tsx              # Label component?   ?       ??? modal-dialog.tsx       # Modal dialog component?   ?       ??? select.tsx             # Select component?   ?       ??? standard-dropdown.tsx  # Standard dropdown component?   ?       ??? table.tsx              # Table components?   ?       ??? tabs.tsx               # Tabs component?   ?       ??? textarea.tsx           # Textarea component?   ??? contexts/?   ?   ??? AuthContext.tsx            # Authentication context?   ?   ??? TranslationContext.tsx     # Translation context?   ??? hooks/?   ?   ??? useAuth.tsx                # Authentication hook?   ?   ??? useTranslation.tsx         # Translation hook?   ?   ??? useTranslate.tsx           # Translation utilities?   ??? lib/              # Utility functions and libraries?   ?   ??? auth.server.ts             # Server-side auth utilities?   ?   ??? auth.ts                    # Auth utilities?   ?   ??? i18n/                      # Internationalization utilities?   ?   ?   ??? config.ts              # i18n configuration?   ?   ?   ??? translations.ts        # Translation utilities?   ?   ??? prisma.ts                  # Prisma client setup?   ?   ??? utils.ts                   # Helper utilities?   ??? translations/     # Translation files?   ?   ??? en.json                    # English translations?   ?   ??? es.json                    # Spanish translations?   ?   ??? [other-languages].json     # Other language translations?   ??? types/            # TypeScript type definitions?       ??? auth.ts                    # Auth types?       ??? user.ts                    # User types?       ??? service.ts                 # Service types?       ??? location.ts                # Location types?       ??? index.ts                   # Common types??? package.json          # Project dependencies??? next.config.js        # Next.js configuration??? tsconfig.json         # TypeScript configuration```## Key Architectural Components### App Router StructureThe application uses Next.js App Router, organizing routes by folders. Each route folder may contain:- `page.tsx`: The main page component- `layout.tsx`: Layout wrapper for the page- `loading.tsx`: Loading state- `error.tsx`: Error handling### Component OrganizationComponents are organized by purpose:1. **Layout Components**: Structural elements used throughout the application2. **UI Components**: Reusable UI elements like buttons, inputs, dialogs3. **Module Components**: Feature-specific components organized by module4. **Style Guide Components**: Components used in the style guide### API StructureAPI routes follow a RESTful pattern:- `/api/[resource]`: Collection endpoints (GET, POST)- `/api/[resource]/[id]`: Instance endpoints (GET, PUT, DELETE)- `/api/[resource]/[id]/[action]`: Action endpoints (PATCH, POST)### Context ProvidersThe application uses React Context for state management:1. **AuthContext**: Manages user authentication and permissions2. **TranslationContext**: Provides translation functionality throughout the app### Database SchemaThe database schema is defined in Prisma's schema.prisma file, with these core models:1. **User**: User accounts and permissions2. **Location**: Countries and regions3. **Service**: Available services4. **DSX**: Data and document requirements5. **Customer**: Customer accounts and configurations## File Naming Conventions- **Component Files**: PascalCase (e.g., `UserForm.tsx`)- **Utility Files**: camelCase (e.g., `authUtils.ts`)- **Route Files**: kebab-case for route segments- **API Routes**: kebab-case for route segments and parameters## Import Conventions- Use absolute imports with `@/` prefix for project files- Group imports in this order:  1. React and Next.js imports  2. Third-party library imports  3. Project imports (components, utilities, types)  4. CSS imports# UI Standards and Styling## Core Styling Principles1. **Centered Content with Side Borders**: Main content is centered with a maximum width and white background to provide a clean reading experience.2. **Button-Based Navigation**: Navigation elements are consistently styled as buttons for visual clarity and to improve user interaction.3. **Modern Typography**: The application uses Inter, a clean modern sans-serif font designed for screen readability.4. **Consistent Dropdown Styling**: Form elements like dropdowns follow a unified design pattern.5. **Standardized Form Layouts**: All forms follow a consistent table-based layout with aligned labels and inputs.6. **Reusable Components**: Common UI elements like action dropdowns use the same component across all pages.## Layout StructureOur layout is built with these key components:1. **Root Layout** (`src/app/layout.tsx`):   - Provides the main structure for the entire application   - Implements the centered content container with side borders   - Manages the maximum width (1024px) and background styling   - Wraps the application with the authentication provider2. **Content Containers**:   - Content uses consistent padding (24px) within the main container   - Page sections use semantic spacing following a vertical rhythm3. **Navigation** (`src/components/layout/main-nav.tsx`):   - Header features right-aligned authentication buttons   - Secondary navigation uses button-styled links   - Active state is clearly highlighted## TypographyWe've implemented the Inter font family as our primary typeface:```csshtml {  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;}```## Color SystemThe application uses a CSS variable-based color system defined in the :root selector in globals.css. Key colors include:- Primary: Blue (#3b82f6) - used for primary actions and navigation- Background: Light gray for body, white for content areas- Text: Dark gray for primary text, medium gray for secondary text- Action colors:  - Standard actions: Blue (rgb(37, 99, 235))  - Destructive actions: Red (rgb(220, 38, 38))  - Dropdown button: Gray (rgb(243, 244, 246))## Component Styling### Interactive Elements1. **Buttons**:   - Primary: Blue background with white text   - Outline: White background with blue border and text   - Destructive: Red background with white text   - Fixed heights for consistent appearance2. **Form Elements**:   - Dropdowns use a consistent styling pattern with hover and focus states     - Height: 28px (fixed)     - White background for dropdown contents     - Light blue hover state for items   - Checkboxes have standardized dimensions and clear states     - Dimensions: 16px ? 16px (square)     - 8px spacing between checkbox and label     - Rounded corners (2px radius)     - Blue background when checked   - Buttons follow a uniform styling pattern3. **Cards**:   - Used for grouping related content   - Consistent header and content padding4. **Action Dropdowns**:   - All actions in tables use the ActionDropdown component   - Consistent style with gray background button and "Actions ?" text   - Dropdown menu with blue text for standard actions, red text for destructive actions   - Fixed width of 80px for the dropdown menu## Standard Dropdown ComponentThe `StandardDropdown` component ensures consistent appearance and behavior for all dropdown elements:```tsx<StandardDropdown  id="my-dropdown"  options={options}  value={selectedValue}  onChange={setSelectedValue}  placeholder="Select an option"/>```Dropdown options should follow this structure:```typescriptinterface DropdownOption {  id: string;    // Unique identifier  value: string; // Value to be passed to onChange  label: string; // Text displayed in the dropdown}```## Form Styling### Form Table StructureAll GlobalRx forms follow a table-based layout with three columns for consistent alignment and spacing:1. **Label Column** (left):   - Fixed width (150px)   - Right-aligned text   - Consistent padding   - Vertically aligned with inputs2. **Input Column** (center):   - Flexible width (expands as needed)   - Contains form controls and error messages   - Maintains consistent height for all inputs (28px for dropdowns, 40px for text inputs)3. **Info Column** (right):   - Fixed width (100px)   - Contains "Required"/"Optional" indicators   - May contain additional actions or help textExample:```tsx<FormTable>  <FormRow     label="Field Name"     htmlFor="fieldId"     required={true}    error={errors.fieldName}  >    <Input id="fieldId" value={value} onChange={handleChange} />  </FormRow>    {/* More rows... */}</FormTable><FormActions>  <Button type="button" variant="outline" onClick={handleCancel}>    Cancel  </Button>  <Button type="submit">Submit</Button></FormActions>```## Table Standards### Table LayoutAll tables in GlobalRx should follow these standards:1. **Full Width**: Tables should use the full available width of their container   - Add `className="w-full"` to the Table component   - Use `className="table-fixed"` for consistent column widths2. **Column Sizing**:   - Define column widths consistently across tables   - Use percentage-based widths (e.g., "25%", "10%")   - Apply styles to both TableHead and TableCell elements3. **Text Formatting**:   - Use `className="truncate"` for cells that might contain longer text   - Add appropriate font weights (e.g., `className="font-medium"` for important cells)Example implementation:```tsxconst columnWidths = {  name: "25%",  category: "15%",  description: "30%",  usage: "10%",  status: "10%",  actions: "10%"};<Table className="w-full table-fixed">  <TableHeader>    <TableRow>      <TableHead style={{ width: columnWidths.name }}>Name</TableHead>      <TableHead style={{ width: columnWidths.category }}>Category</TableHead>      {/* More headers... */}    </TableRow>  </TableHeader>  <TableBody>    {items.map((item) => (      <TableRow key={item.id}>        <TableCell           className="font-medium truncate"          style={{ width: columnWidths.name }}        >          {item.name}        </TableCell>        {/* More cells... */}      </TableRow>    ))}  </TableBody></Table>```## Responsive Design Guidelines1. **Minimum Widths**: All content containers have minimum widths to ensure usability on smaller screens.2. **Mobile Breakpoints**: Use Tailwind's responsive prefixes (`sm:`, `md:`, `lg:`) for different screen sizes.3. **Horizontal Scrolling**: Tables can horizontally scroll on small screens when necessary.4. **Stack on Mobile**: Multi-column layouts stack vertically on small screens where appropriate.## CSS ClassesThe following CSS classes are defined in `globals.css` for consistent styling:### Layout Classes- `.centered-container`: Centers content with a max-width and white background- `.content-section`: Applies consistent padding to content sections### Form Classes- `.form-table`: Base styles for form tables- `.form-label` and `.form-label-top`: Styles for label cells- `.form-input` and `.form-input-top`: Styles for input cells- `.form-info`: Styles for info/action cells- `.form-required` and `.form-optional`: Styles for requirement indicators- `.form-error`: Styles for error messages### Dropdown Classes- `.standard-dropdown`: Container for custom dropdowns- `.dropdown-trigger`: Trigger button for dropdowns- `.dropdown-menu`: Container for dropdown options- `.dropdown-item`: Individual dropdown options- `.dropdown-placeholder`: Placeholder text styling## Technical ImplementationOur styling approach leverages:1. **Tailwind CSS**: For utility-based styling2. **CSS Variables**: For theme definition3. **Component-based Styling**: For reusable UI elements4. **Global CSS Classes**: For consistent patterns like forms## Best Practices1. **Maintain Consistency**: Follow established patterns when adding new elements2. **Centralize Changes**: Update global styles in globals.css when making site-wide changes3. **Component Organization**: Keep UI components in their appropriate folders4. **Responsive Design**: Ensure all components work well across different screen sizes5. **Use Form Components**: Always use FormTable, FormRow, and FormActions for forms6. **Follow Checkbox Standards**: Use the established pattern for checkboxes to ensure proper appearance7. **Use ActionDropdown**: Always use the ActionDropdown component for action menus in tables8. **Document Exceptions**: If you need to deviate from standards, document why in a comment# Dialog Implementation Standards## OverviewThe GlobalRx application uses native HTML `<dialog>` elements for all modal interactions, with a standardized component pattern. This approach offers superior performance, reliability, and consistent user experience.## Implementation Approach### Why Native HTML Dialogs?The application uses native HTML `<dialog>` elements instead of component library alternatives for several reasons:1. **Performance**: Fewer layers of abstraction means better performance2. **Reliability**: Direct browser implementation reduces bugs and edge cases3. **Browser Support**: Native support in all modern browsers with polyfill for older ones4. **Z-index Management**: Simpler z-index handling prevents visibility issues5. **Consistent Behavior**: More predictable behavior across different contexts## ModalDialog ComponentUse the standardized `ModalDialog` component for all new dialogs:```tsximport { useRef } from 'react';import { ModalDialog, DialogRef, DialogFooter } from '@/components/ui/modal-dialog';export function MyComponent() {  const dialogRef = useRef<DialogRef>(null);    const openDialog = () => {    dialogRef.current?.showModal();  };    const handleConfirm = () => {    // Perform action    dialogRef.current?.close();  };    return (    <>      <Button onClick={openDialog}>Open Dialog</Button>            <ModalDialog        ref={dialogRef}        title="My Dialog Title"        footer={          <DialogFooter             onCancel={() => dialogRef.current?.close()}            onConfirm={handleConfirm}            confirmText="Save Changes"          />        }      >        <div className="py-4">          Dialog content goes here        </div>      </ModalDialog>    </>  );}```### Props ReferenceThe `ModalDialog` component accepts the following props:| Prop | Type | Required | Description ||------|------|----------|-------------|| `title` | string | Yes | Dialog title displayed in the header || `children` | ReactNode | Yes | Content of the dialog || `footer` | ReactNode | No | Footer content, typically buttons || `maxWidth` | "sm" \| "md" \| "lg" \| "xl" \| "2xl" \| "full" | No | Maximum width of the dialog (default: "md") || `onClose` | () => void | No | Callback when dialog is closed |### DialogRef MethodsThe dialog ref exposes these methods:| Method | Description ||--------|-------------|| `showModal()` | Opens the dialog || `close()` | Closes the dialog |### DialogFooter ComponentFor consistent button placement, use the `DialogFooter` component:```tsx<DialogFooter  onCancel={handleCancel}  onConfirm={handleConfirm}  cancelText="Discard"  confirmText="Save"  disabled={!isValid}  loading={isSubmitting}/>```## Dialog StructureEach dialog should follow this structure:1. **Header**:   - Title (left-aligned)   - Close button (right-aligned)2. **Content**:   - Main dialog content   - Form elements follow standard form layout3. **Footer**:   - Action buttons   - Cancel button (left/outline)   - Confirm button (right/filled)## Dialog StylingAll dialogs use a consistent style:```cssdialog {  padding: 0;  border-radius: 0.5rem;  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);  background-color: white;  width: 100%;  max-width: [size]; /* sm, md, lg, xl, 2xl */}dialog::backdrop {  background-color: rgba(0, 0, 0, 0.5);}```## Accessibility RequirementsAll dialogs should meet these accessibility standards:1. **Keyboard navigation**: Users must be able to navigate using the Tab key2. **Focus management**: Focus should be trapped within the dialog when open3. **Escape key**: ESC key should close dialogs4. **Screen readers**: Ensure proper ARIA roles and labels5. **Close button**: All dialogs must have a visible close button## Dialog Types### Form DialogsFor dialogs containing forms:1. Use the standard form layout with right-aligned labels2. Follow the button order: Cancel (left), Submit (right)3. Validate forms before closingExample:```tsx<ModalDialog  ref={dialogRef}  title="Edit User"  footer={    <DialogFooter      onCancel={handleCancel}      onConfirm={handleSubmit}      confirmText="Save User"      disabled={!isValid}    />  }>  <form className="grid gap-4 py-4">    <div className="grid grid-cols-4 items-center gap-4">      <Label htmlFor="name" className="text-right">Name</Label>      <Input        id="name"        value={name}        onChange={(e) => setName(e.target.value)}        className="col-span-3"      />    </div>        <div className="grid grid-cols-4 items-center gap-4">      <Label htmlFor="email" className="text-right">Email</Label>      <Input        id="email"        type="email"        value={email}        onChange={(e) => setEmail(e.target.value)}        className="col-span-3"      />    </div>  </form></ModalDialog>```### Confirmation DialogsFor simple confirmation dialogs:```tsx<ModalDialog  ref={confirmDialogRef}  title="Confirm Action"  footer={    <DialogFooter      onCancel={() => confirmDialogRef.current?.close()}      onConfirm={handleConfirmAction}      confirmText="Confirm"    />  }>  <p>Are you sure you want to perform this action?</p></ModalDialog>```### Alert DialogsFor alert messages that don't require confirmation:```tsx<ModalDialog  ref={alertDialogRef}  title="Information"  footer={    <Button onClick={() => alertDialogRef.current?.close()}>      Dismiss    </Button>  }>  <p>This is an informational message.</p></ModalDialog>```## Browser CompatibilityThe native HTML `<dialog>` element is supported in all modern browsers. For older browsers, a polyfill is automatically loaded via the `dialog-polyfill.tsx` component included in the root layout.The polyfill ensures consistent behavior across all browsers, applying the same styling and functionality as the native implementation.## Implementation Examples### Basic Dialog```tsxconst dialogRef = useRef<DialogRef>(null);// Open dialogconst openDialog = () => {  dialogRef.current?.showModal();};// Close dialogconst closeDialog = () => {  dialogRef.current?.close();};<ModalDialog  ref={dialogRef}  title="Example Dialog"  footer={    <>      <Button variant="outline" onClick={closeDialog}>        Cancel      </Button>      <Button onClick={handleSubmit}>        Submit      </Button>    </>  }>  <div className="p-4">    <p>Dialog content goes here.</p>  </div></ModalDialog>```### Form Dialog with Validation```tsxconst [name, setName] = useState('');const [isValid, setIsValid] = useState(false);const [isSubmitting, setIsSubmitting] = useState(false);const dialogRef = useRef<DialogRef>(null);// Validate formuseEffect(() => {  setIsValid(name.trim().length > 0);}, [name]);// Handle submitconst handleSubmit = async () => {  if (!isValid) return;    setIsSubmitting(true);  try {    await saveData({ name });    dialogRef.current?.close();  } catch (error) {    console.error('Error saving:', error);  } finally {    setIsSubmitting(false);  }};<ModalDialog  ref={dialogRef}  title="Add New Item"  footer={    <DialogFooter      onCancel={() => dialogRef.current?.close()}      onConfirm={handleSubmit}      disabled={!isValid}      loading={isSubmitting}    />  }>  <div className="grid gap-4 py-4">    <div className="grid grid-cols-4 items-center gap-4">      <Label htmlFor="name" className="text-right">Name</Label>      <Input        id="name"        value={name}        onChange={(e) => setName(e.target.value)}        className="col-span-3"      />    </div>  </div></ModalDialog>```# Form Standards## Form Layout and StructureAll forms in the GlobalRx application follow a consistent table-based layout for alignment and visual consistency.### Form Table ComponentUse the `FormTable` component as the container for all forms:```tsximport { FormTable, FormRow, FormActions } from '@/components/ui/form';<FormTable>  {/* Form rows go here */}</FormTable>```### Form Row StructureEach form row follows a three-column structure:1. **Label Column** (left):   - Fixed width (150px)   - Right-aligned text   - Contains label with `htmlFor` attribute2. **Input Column** (center):   - Flexible width   - Contains the input control   - Shows error messages if applicable3. **Info Column** (right):   - Fixed width (100px)   - Contains "Required"/"Optional" indicators   - May contain help text or additional actionsExample:```tsx<FormRow  label="Username"  htmlFor="username"  required={true}  error={errors.username}>  <Input    id="username"    value={username}    onChange={(e) => setUsername(e.target.value)}    placeholder="Enter username"  /></FormRow>```### Form ActionsUse the `FormActions` component for form buttons:```tsx<FormActions>  <Button variant="outline" onClick={handleCancel}>    Cancel  </Button>  <Button type="submit" disabled={!isValid}>    Submit  </Button></FormActions>```## Form Elements### Input FieldsAll text inputs should:- Have a consistent height (28px)- Include proper labels with `htmlFor` attributes- Display error messages when validation fails```tsx<FormRow label="Email" htmlFor="email" required={true} error={errors.email}>  <Input    id="email"    type="email"    value={email}    onChange={(e) => setEmail(e.target.value)}    placeholder="Enter email address"  /></FormRow>```### DropdownsUse the `StandardDropdown` component for all dropdown selectors:```tsx<FormRow label="Country" htmlFor="country" required={true}>  <StandardDropdown    id="country"    options={countryOptions}    value={selectedCountry}    onChange={setSelectedCountry}    placeholder="Select a country"  /></FormRow>```The options array should follow this structure:```typescriptconst options = [  { id: 'option1', value: 'option1', label: 'Option 1' },  { id: 'option2', value: 'option2', label: 'Option 2' },];```### CheckboxesCheckboxes should be implemented with consistent sizing and spacing:```tsx<div className="flex items-center gap-2">  <div className="w-4 h-4 flex-shrink-0 relative">    <Checkbox      id="termsCheckbox"      checked={agreed}      onCheckedChange={setAgreed}      className="w-4 h-4 min-h-4 min-w-4"    />  </div>  <Label     htmlFor="termsCheckbox"     className="text-sm"  >    I agree to the terms and conditions  </Label></div>```Key points for checkboxes:- Use 16px ? 16px dimensions (or 4 in Tailwind units)- Maintain 8px gap between checkbox and label- Use a container to ensure proper alignment### TextareasTextareas should follow the same pattern as other inputs:```tsx<FormRow label="Description" htmlFor="description">  <Textarea    id="description"    value={description}    onChange={(e) => setDescription(e.target.value)}    rows={4}    placeholder="Enter description"  /></FormRow>```## Form Validation### Client-Side ValidationUse React Hook Form with Zod for form validation:```tsximport { useForm } from 'react-hook-form';import { zodResolver } from '@hookform/resolvers/zod';import * as z from 'zod';// Define validation schemaconst formSchema = z.object({  name: z.string().min(1, "Name is required"),  email: z.string().email("Invalid email address"),});// Type inferred from schematype FormValues = z.infer<typeof formSchema>;// In your componentconst {  register,  handleSubmit,  formState: { errors, isValid },} = useForm<FormValues>({  resolver: zodResolver(formSchema),  mode: 'onChange',});const onSubmit = (data: FormValues) => {  // Handle form submission};```### Error DisplayDisplay validation errors below the input field:```tsx<FormRow   label="Email"   htmlFor="email"   required={true}   error={errors.email?.message}>  <Input    id="email"    {...register('email')}  /></FormRow>```The `FormRow` component will automatically display the error message when provided.## Required and Optional FieldsClearly indicate which fields are required and which are optional:```tsx// Required field (default)<FormRow label="Name" htmlFor="name" required={true}>  <Input id="name" {...register('name')} /></FormRow>// Optional field<FormRow label="Phone" htmlFor="phone" required={false}>  <Input id="phone" {...register('phone')} /></FormRow>```The `FormRow` component will automatically display "Required" or "Optional" in the info column based on the `required` prop.## Form OrganizationFor complex forms, organize fields into logical sections:```tsx<FormTable>  <h3 className="text-lg font-semibold mb-4">Personal Information</h3>    <FormRow label="First Name" htmlFor="firstName" required={true}>    <Input id="firstName" {...register('firstName')} />  </FormRow>    <FormRow label="Last Name" htmlFor="lastName" required={true}>    <Input id="lastName" {...register('lastName')} />  </FormRow>    <h3 className="text-lg font-semibold mb-4 mt-8">Contact Information</h3>    <FormRow label="Email" htmlFor="email" required={true}>    <Input id="email" type="email" {...register('email')} />  </FormRow>    <FormRow label="Phone" htmlFor="phone" required={false}>    <Input id="phone" {...register('phone')} />  </FormRow>    <FormActions>    <Button type="button" variant="outline" onClick={handleCancel}>Cancel</Button>    <Button type="submit">Submit</Button>  </FormActions></FormTable>```## Form in DialogsWhen using forms in dialogs, maintain the same layout pattern:```tsx<ModalDialog  ref={dialogRef}  title="Add New User"  footer={    <>      <Button variant="outline" onClick={() => dialogRef.current?.close()}>        Cancel      </Button>      <Button         onClick={handleSubmit(onSubmit)}         disabled={!isValid || isSubmitting}      >        {isSubmitting ? 'Saving...' : 'Save User'}      </Button>    </>  }>  <FormTable>    <FormRow label="Name" htmlFor="name" required={true} error={errors.name?.message}>      <Input id="name" {...register('name')} />    </FormRow>        <FormRow label="Email" htmlFor="email" required={true} error={errors.email?.message}>      <Input id="email" type="email" {...register('email')} />    </FormRow>  </FormTable></ModalDialog>```## Handling Form SubmissionFollow this pattern for form submission:```tsxconst handleSubmit = async (data: FormValues) => {  setIsSubmitting(true);    try {    // Call API    const response = await fetch('/api/resource', {      method: 'POST',      headers: {        'Content-Type': 'application/json',      },      body: JSON.stringify(data),    });        if (!response.ok) {      throw new Error('Failed to submit form');    }        // Handle success    toast.success('Form submitted successfully');    reset(); // Reset form if needed      } catch (error) {    // Handle error    console.error('Error submitting form:', error);    toast.error('Failed to submit form');      } finally {    setIsSubmitting(false);  }};```## Best Practices1. **Consistent Layout**: Use the same form layout pattern throughout the application2. **Validation**: Always include client-side validation3. **Loading States**: Show loading indicators during form submission4. **Error Handling**: Display appropriate error messages5. **Accessibility**: Ensure all form elements are properly labeled and accessible6. **Required Fields**: Clearly indicate which fields are required7. **Responsive Design**: Ensure forms work well on all screen sizes8. **Consistent Heights**: Maintain consistent heights for all input elements (28px)9. **Button Order**: Follow the conventional button order: Cancel (left), Submit (right)# Table Standards# Table Standards## Table Structure and LayoutAll tables in the GlobalRx application follow a consistent structure to ensure a uniform appearance and behavior across the platform.### Basic Table StructureUse the Shadcn UI table components with consistent class names:```tsximport {  Table,  TableHeader,  TableBody,  TableHead,  TableRow,  TableCell} from '@/components/ui/table';<Table className="w-full table-fixed">  <TableHeader>    <TableRow>      <TableHead>Column 1</TableHead>      <TableHead>Column 2</TableHead>      <TableHead>Column 3</TableHead>    </TableRow>  </TableHeader>  <TableBody>    {items.map((item) => (      <TableRow key={item.id}>        <TableCell>{item.column1}</TableCell>        <TableCell>{item.column2}</TableCell>        <TableCell>{item.column3}</TableCell>      </TableRow>    ))}  </TableBody></Table>```### Column Width DefinitionDefine column widths using a consistent approach:```tsx// Define column widths as percentagesconst columnWidths = {  name: "25%",  category: "15%",  description: "30%",  status: "10%",  date: "10%",  actions: "10%"};// Apply to both headers and cells<TableHead style={{ width: columnWidths.name }}>Name</TableHead><TableCell style={{ width: columnWidths.name }}>{item.name}</TableCell>```### Table Width and LayoutAlways set tables to use the full available width and fixed layout:```tsx<Table className="w-full table-fixed">  {/* Table content */}</Table>```For tables that may contain a lot of data, wrap them in a container with horizontal scrolling:```tsx<div className="w-full overflow-x-auto">  <Table className="w-full table-fixed">    {/* Table content */}  </Table></div>```## Header StylingTable headers should be styled consistently:```tsx<TableHeader className="bg-gray-100">  <TableRow>    <TableHead className="font-semibold">Column 1</TableHead>    <TableHead className="font-semibold">Column 2</TableHead>  </TableRow></TableHeader>```## Row Styling### Alternating Row ColorsFor better readability, use alternating row colors:```tsx<TableBody>  {items.map((item, index) => (    <TableRow       key={item.id}      className={index % 2 === 0 ? 'bg-white' : 'bg-gray-50'}    >      {/* Row cells */}    </TableRow>  ))}</TableBody>```### Hover EffectsAdd hover effects to rows for better user experience:```tsx<TableRow className="hover:bg-blue-50 transition-colors">  {/* Row cells */}</TableRow>```### Disabled/Inactive RowsFor disabled or inactive items, use a muted text color:```tsx<TableRow className={item.disabled ? 'text-gray-400' : ''}>  {/* Row cells */}</TableRow>```## Cell Styling### Text TruncationFor cells that might contain long text, use the `truncate` class and add a title for hover tooltip:```tsx<TableCell   className="truncate"   title={item.longDescription}>  {item.longDescription}</TableCell>```### Cell Content Alignment- Text content: Left-aligned (default)- Numeric content: Right-aligned- Status indicators: Center-aligned- Action buttons: Center-aligned```tsx<TableCell className="text-right">{item.amount}</TableCell><TableCell className="text-center">{item.status}</TableCell>```## Action Column### ActionDropdown ComponentAlways use the `ActionDropdown` component for action menus in tables:```tsximport { ActionDropdown } from '@/components/ui/action-dropdown';// In your componentconst actionOptions = [  {    label: "Edit",    onClick: () => handleEdit(item),    color: "rgb(37, 99, 235)" // Blue color  },  {    label: "Delete",    onClick: () => handleDelete(item.id),    color: "rgb(220, 38, 38)" // Red color for destructive actions  }];// In your table cell<TableCell className="text-center">  <ActionDropdown options={actionOptions} /></TableCell>```### Action OptionsFollow these conventions for action options:- Use blue color (`rgb(37, 99, 235)`) for standard actions- Use red color (`rgb(220, 38, 38)`) for destructive actions- Keep labels short and descriptive- Always position the Actions column as the last column## Empty State HandlingAlways provide a clear message when a table has no data:```tsx{items.length === 0 ? (  <TableRow>    <TableCell       colSpan={columnCount}       className="text-center py-8 text-gray-500"    >      No items found. {actionText && `Click "${actionText}" to create one.`}    </TableCell>  </TableRow>) : (  // Regular table rows)}```## Loading StateShow a clear loading state when fetching data:```tsx{isLoading ? (  <TableRow>    <TableCell       colSpan={columnCount}       className="text-center py-8"    >      <div className="flex justify-center items-center">        <svg className="animate-spin h-5 w-5 mr-3 text-blue-500" viewBox="0 0 24 24">          {/* Spinner SVG */}        </svg>        Loading...      </div>    </TableCell>  </TableRow>) : (  // Regular table content)}```## PaginationUse a consistent pagination component for all tables with multiple pages:```tsx<div className="flex justify-between items-center mt-4 pt-4 border-t border-gray-200">  <div className="text-sm text-gray-500">    Showing page {currentPage} of {totalPages}  </div>  <div className="flex space-x-2">    <Button      variant="outline"      onClick={() => setCurrentPage((prev) => Math.max(prev - 1, 1))}      disabled={currentPage === 1}    >      Previous    </Button>    <Button      variant="outline"      onClick={() => setCurrentPage((prev) => Math.min(prev + 1, totalPages))}      disabled={currentPage === totalPages}    >      Next    </Button>  </div></div>```## Filtering and SearchingFor tables with filtering and searching capabilities, use a consistent filter bar:```tsx<div className="mb-6 grid gap-4 md:grid-cols-2 lg:grid-cols-3">  <div>    <Input      placeholder="Search..."      value={searchTerm}      onChange={(e) => setSearchTerm(e.target.value)}      className="w-full"    />  </div>    <div>    <StandardDropdown      id="category-filter"      options={categoryOptions}      value={selectedCategory}      onChange={setSelectedCategory}      placeholder="All Categories"    />  </div>    <div className="flex items-center">    <div className="flex items-center space-x-2">      <Checkbox        id="showDisabled"        checked={showDisabled}        onCheckedChange={setShowDisabled}      />      <Label htmlFor="showDisabled">        Show disabled items      </Label>    </div>  </div></div>```## Table GroupingWhen grouping table data by categories, use consistent section headers:```tsx{Object.entries(groupedItems).map(([group, itemsInGroup]) => (  <div key={group} className="mb-8">    <h3 className="text-xl font-semibold mb-2">{group}</h3>        <Table className="w-full table-fixed">      <TableHeader>        {/* Headers */}      </TableHeader>      <TableBody>        {itemsInGroup.map(item => (          <TableRow key={item.id}>            {/* Row cells */}          </TableRow>        ))}      </TableBody>    </Table>  </div>))}```## SortingFor sortable columns, add sort indicators and handlers:```tsx<TableHead   className="cursor-pointer hover:bg-gray-200"  onClick={() => handleSort('name')}>  Name  {sortField === 'name' && (    <span className="ml-1">      {sortDirection === 'asc' ? '?' : '?'}    </span>  )}</TableHead>```## SelectionFor tables that support row selection:```tsx<TableRow className={selectedItems.includes(item.id) ? 'bg-blue-50' : ''}>  <TableCell>    <Checkbox      checked={selectedItems.includes(item.id)}      onCheckedChange={(checked) => {        if (checked) {          setSelectedItems(prev => [...prev, item.id]);        } else {          setSelectedItems(prev => prev.filter(id => id !== item.id));        }      }}    />  </TableCell>  {/* Other cells */}</TableRow>```For "select all" functionality:```tsx<TableHead>  <Checkbox    checked={selectedItems.length === items.length}    onCheckedChange={(checked) => {      if (checked) {        setSelectedItems(items.map(item => item.id));      } else {        setSelectedItems([]);      }    }}  /></TableHead>```## Table CustomizationIf customization is needed for specific use cases, create a wrapper component that maintains the same standards while adding the required functionality.## Accessibility ConsiderationsEnsure all tables are accessible:1. Use proper table semantics with `<table>`, `<thead>`, `<tbody>`, `<th>`, and `<td>` elements2. Provide adequate color contrast3. Use aria-labels where appropriate4. Ensure keyboard navigability## Mobile ResponsivenessFor mobile-responsive tables, consider these approaches:1. **Horizontal scrolling** for tables with many columns2. **Stacked layout** for mobile views, where each row becomes a card3. **Column hiding** to prioritize important columns on small screens## Best Practices1. **Consistent Column Widths**: Define and apply consistent column widths across related tables2. **Fixed Header**: For long tables, consider using a fixed header that stays visible when scrolling3. **Row Height**: Maintain consistent row heights (avoid rows with varying heights)4. **Empty State**: Always provide clear empty states5. **Loading Indicators**: Show clear loading states6. **Action Placement**: Always place action buttons/menus in the rightmost column7. **Text Truncation**: Use truncation for cells that may contain long text# Translation System# Translation System## OverviewThe GlobalRx application includes a comprehensive translation system that enables multilingual support across the application. This system allows administrators to manage translations for all text content through an intuitive interface and supports importing/exporting translations via CSV files.## ArchitectureThe translation system consists of these key components:1. **Translation Files**: JSON files stored in `/src/translations/` directory2. **TranslationContext**: React context provider for accessing translations3. **Translation Hooks**: Hooks for using translations in components4. **Translation Management UI**: Admin interface for managing translations## Translation KeysAll text in the application should use translation keys instead of hardcoded strings. Translation keys follow this format:- `module.section.element` - For module-specific text- `common.action` - For common UI elements- `app.section` - For application-level textExamples:- `module.userAdmin.title` - Title for the User Admin module- `common.save` - Text for save buttons- `app.welcome.title` - Welcome message on the homepage## Implementation in Components### Server ComponentsFor server components (pages), use the `data-i18n-key` attribute on HTML elements:```tsx// Before<h1 className="text-2xl font-bold mb-6">Global Configurations</h1>// After<h1 className="text-2xl font-bold mb-6" data-i18n-key="config.global.title">  Global Configurations</h1>```The `PageContent` component will automatically replace these elements with their translated versions on the client side.Make sure to wrap server components that need translations in the `PageContent` component:```tsximport { PageContent } from '@/components/layout/PageContent';export default function MyPage() {  return (    <PageContent>      <h1 data-i18n-key="my.page.title">My Page</h1>      {/* Rest of the page */}    </PageContent>  );}```### Client ComponentsFor client components, use the `useTranslation` hook:```tsx// Beforefunction MyComponent() {  return (    <button>Save</button>  );}// Afterimport { useTranslation } from '@/contexts/TranslationContext';function MyComponent() {  const { t } = useTranslation();    return (    <button>{t('common.save')}</button>  );}```For client components with more complex translations, you can also use the `Translate` component from `useTranslate`:```tsximport { useTranslate } from '@/hooks/useTranslate';function MyComponent() {  const { Translate } = useTranslate();    return (    <div>      <Translate id="my.complex.content">        This is some complex content that will be translated      </Translate>    </div>  );}```## Translation Management### Adding New TranslationsWhen adding new text to the application:1. Add the translation key and English text to `/src/translations/en.json`2. Update other language files with empty strings or initial translations3. Use the key in your componentsExample of adding a new key:```json// In en.json{  "my.new.feature": "My New Feature"}// In es.json{  "my.new.feature": "Mi Nueva Caracter’stica"}```### Translation Management UIThe application includes a dedicated UI for managing translations in the Global Configurations module:1. **By Keys View**: Displays translation keys with values for all languages2. **By Languages View**: Organizes translations by language3. **Search Functionality**: Filter translations by key or content4. **Inline Editing**: Edit translations directly in the UI5. **Import/Export**: Import and export translations via CSV#### Using the Translation Management UI1. Navigate to the Global Configurations module2. Select the Translations tab3. Use the "By Keys" view to see all keys across languages4. Use the "By Languages" view to focus on a specific language5. Click "Add New Translation Key" to add a new key6. Click "Save Changes" to save edits to a language### Adding New LanguagesTo add a new language:1. Go to the Translations tab in Global Configurations2. Click "Add New Language"3. Enter the locale code (e.g., "fr" for French)4. Enter the display name (e.g., "French")5. Click "Add Language"The system will automatically create a new translation file with empty translations based on the English keys.### Import/ExportFor bulk translation management:1. Export translations to CSV using the "Export to CSV" button2. Edit the CSV file in a spreadsheet application3. Import the updated CSV using the "Import from CSV" buttonThe CSV format includes a column for the key and a column for each language.## Technical Implementation### Translation FilesTranslation files are stored as JSON files in the `/src/translations/` directory:```/src/translations/  en.json    # English translations (default)  es.json    # Spanish translations  fr.json    # French translations  ...```Each file contains key-value pairs where the key is the translation key and the value is the translated text:```json{  "common.save": "Save",  "common.cancel": "Cancel",  "common.delete": "Delete",  "module.userAdmin.title": "User Administration"}```### TranslationContextThe `TranslationContext` provides translations to all components:```tsx// src/contexts/TranslationContext.tsximport React, { createContext, useContext, useState, useEffect } from 'react';const TranslationContext = createContext({  locale: 'en',  setLocale: (locale: string) => {},  t: (key: string) => '',  translations: {}});export const TranslationProvider = ({ children }) => {  const [locale, setLocale] = useState('en');  const [translations, setTranslations] = useState({});  // Load translations  useEffect(() => {    async function loadTranslations() {      const translations = await fetch(`/api/translations?locale=${locale}`);      const data = await translations.json();      setTranslations(data);    }        loadTranslations();  }, [locale]);  // Translation function  const t = (key: string) => {    return translations[key] || key;  };  return (    <TranslationContext.Provider value={{ locale, setLocale, t, translations }}>      {children}    </TranslationContext.Provider>  );};export const useTranslation = () => useContext(TranslationContext);```### API RoutesThe translation system uses these API routes:- `GET /api/translations?locale=en` - Get translations for a specific locale- `POST /api/translations/save` - Save translations for a locale- `POST /api/translations/import` - Import translations from CSV- `POST /api/translations/add-locale` - Add a new locale### PageContent ComponentThe `PageContent` component handles translations in server components:```tsx// src/components/layout/PageContent.tsx'use client';import { useEffect } from 'react';import { useTranslation } from '@/contexts/TranslationContext';export function PageContent({ children }) {  const { t } = useTranslation();    useEffect(() => {    // Replace all elements with data-i18n-key    document.querySelectorAll('[data-i18n-key]').forEach(el => {      const key = el.getAttribute('data-i18n-key');      if (key) {        el.textContent = t(key);      }    });  }, [t]);    return <>{children}</>;}```## Conversion ProcessWhen converting an existing component to use translations:1. Identify all text strings in the component2. Create translation keys for each string3. Add the keys and English text to `en.json`4. Add the keys with translations to other language files5. Update the component to use `t()` or `data-i18n-key`6. Test in different languages## Implementation PlanThe implementation of the translation system follows this phased approach:1. **Foundation** (Completed)   - Translation context and hooks   - Initial translation files   - Basic translation functionality2. **Management UI** (Completed)   - Translation tab in Global Configurations   - UI for editing translations   - Import/Export functionality3. **Core Components** (Current)   - Update shared components to use translations   - Convert layouts and navigation4. **Module Conversion** (Upcoming)   - Systematically convert each module   - Update all user-facing text5. **Testing and Refinement** (Future)   - Test with various languages   - Optimize performance   - Refine user experience## Best Practices1. **Key Naming**: Use a consistent structure for translation keys2. **Default Text**: Always include the English text as fallback in components3. **Context**: Add comments in translation files for context when needed4. **Maintenance**: Keep translation files organized and sorted5. **Testing**: Test with languages that have longer text to ensure UI flexibility6. **New Components**: Always use translations for any new components7. **Documentation**: Document translation keys for complex components# Module Documentation# Module Documentation## Module ArchitectureThe GlobalRx platform consists of four primary modules, each designed to handle specific aspects of the global screening process:1. **User Admin**: Manage internal users and permissions2. **Global Configurations**: Configure global settings and references3. **Customer Configurations**: Manage customer accounts and service scopes4. **Candidate Workflow**: Handle candidate applications and data collectionEach module is designed to be independent yet capable of communicating with other modules when necessary via APIs.## Module 1: User Admin### PurposeThe User Admin module manages internal user accounts and their permissions within the GlobalRx platform.### Features1. **User Management**   - Create, edit, and disable user accounts   - Reset passwords   - View user activity2. **Permission Control**   - Assign permissions for:     - Countries     - Services     - DSX     - Customers### Key Components- **User List**: Displays all users with filtering and search- **User Form**: Interface for creating and editing users- **Permission Matrix**: Visual control for assigning permissions### API Endpoints- `GET /api/users` - List all users- `POST /api/users` - Create a new user- `GET /api/users/:id` - Get a specific user- `PUT /api/users/:id` - Update a user- `PATCH /api/users/:id/toggle-status` - Enable/disable a user### Database Structure```prismamodel User {  id            String    @id @default(uuid())  email         String    @unique  password      String  firstName     String?  lastName      String?  permissions   Json      // Stores permissions for countries, services, DSX, customers  disabled      Boolean   @default(false)  createdAt     DateTime  @default(now())  updatedAt     DateTime  @updatedAt}```## Module 2: Global Configurations### PurposeThe Global Configurations module serves as the central repository for system-wide settings and reference data used across the platform.### Features1. **Locations Management**   - Based on ISO country list   - Includes subregion management (up to 3 levels)   - Support for adding/editing/disabling locations2. **Services Management**   - Define services available in the system   - Categorize services by type   - Support for adding/editing/disabling services3. **DSX (Data & Document Requirements)**   - Define data fields required for services   - Specify document requirements by location   - Configure location-specific requirements4. **Translations Management**   - Manage translations for all text in the application   - Add and edit languages   - Import/export translations via CSV### Key Components1. **Locations Tab**   - Location table with search and filter   - Location form for adding/editing   - Hierarchical display of regions/subregions2. **Services Tab**   - Services table grouped by functionality type   - Service form for adding/editing   - Service filter bar with search and categories3. **DSX Tab**   - Matrix view of requirements by location   - Field definition forms   - Document requirement configuration4. **Translations Tab**   - Translation editor with key/language views   - Language management   - Import/export functionality### API Endpoints- `/api/locations` - Manage locations- `/api/services` - Manage services- `/api/dsx` - Manage data and document requirements- `/api/translations` - Manage translations### Database Structure```prismamodel Location {  id         String  @id @default(uuid())  name       String  code_2     String  @unique // 2-letter code  code_3     String  @unique // 3-letter code  numeric    String? // Numeric code  subregion1 String?  subregion2 String?  subregion3 String?  disabled   Boolean @default(false)}model Service {  id               String  @id @default(uuid())  name             String  category         String  description      String?  functionalityType String  // verification, record, other  disabled         Boolean @default(false)  usage            Int     @default(0) // Number of customer packages using this service}model DSXRequirement {  id         String   @id @default(uuid())  serviceId  String  locationId String  fieldId    String?  documentId String?  required   Boolean  @default(false)}model TranslationKey {  id      String @id @default(uuid())  key     String @unique  context String?}model Translation {  id      String @id @default(uuid())  keyId   String  locale  String  value   String}```## Module 3: Customer Configurations### PurposeThe Customer Configurations module manages customer accounts and their specific service settings.### Features1. **Customer Management**   - Create and edit customer accounts   - Capture contact and billing information   - Configure service access2. **Customer Scope**   - Create service packages for customers   - Define scope for each service   - Set location-specific settings### Key Components1. **Customer Edit Tab**   - Customer information form   - Contact management   - Invoicing settings   - Service access control2. **Customer Scope Tab**   - Package creation and management   - Service scope definition   - Location-specific settings### API Endpoints- `/api/customers` - Manage customer accounts- `/api/customers/:id/packages` - Manage customer packages- `/api/customers/:id/services` - Manage customer service access### Database Structure```prismamodel Customer {  id               String    @id @default(uuid())  name             String  address          String?  contactPerson    String?  contactEmail     String?  contactPhone     String?  invoiceTerms     String?  invoiceContact   String?  invoiceDelivery  String?  disabled         Boolean   @default(false)  createdAt        DateTime  @default(now())  updatedAt        DateTime  @updatedAt}model CustomerPackage {  id          String   @id @default(uuid())  customerId  String  name        String  description String?  createdAt   DateTime @default(now())  updatedAt   DateTime @updatedAt}model PackageService {  id        String   @id @default(uuid())  packageId String  serviceId String  scope     Json     // Service-specific scope settings}```## Module 4: Candidate Workflow### PurposeThe Candidate Workflow module handles the collection and processing of candidate data through customizable application forms.### Features1. **Application Forms**   - Multilingual forms for data collection   - Dynamic fields based on service requirements   - Document upload capabilities2. **Workflow Management**   - Track application status   - Process applications through defined steps   - Support for verification and review3. **Multilingual Support**   - Forms available in multiple languages   - Language selection for candidates   - Translation of all UI elements### Key Components1. **Form Builder**   - Create and edit application forms   - Configure field requirements   - Set up conditional logic2. **Workflow Designer**   - Define process steps   - Configure step transitions   - Set up notifications3. **Candidate Portal**   - Multilingual interface   - Progress tracking   - Document upload### API Endpoints- `/api/forms` - Manage application forms- `/api/workflows` - Manage workflow definitions- `/api/applications` - Manage candidate applications### Database Structure```prismamodel Form {  id          String   @id @default(uuid())  name        String  description String?  fields      Json     // Form field definitions  createdAt   DateTime @default(now())  updatedAt   DateTime @updatedAt}model Workflow {  id        String   @id @default(uuid())  name      String  steps     Json     // Workflow step definitions  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt}model Application {  id          String   @id @default(uuid())  candidateId String  formId      String  workflowId  String  data        Json     // Application data  status      String  currentStep String  createdAt   DateTime @default(now())  updatedAt   DateTime @updatedAt}```## Module InteractionThe modules interact with each other through the following relationships:1. **User Admin ? All Modules**   - User permissions control access to all modules   - Permission checks for countries, services, DSX, and customers2. **Global Configurations ? Customer Configurations**   - Services defined in Global Configurations are used in Customer Configurations   - Locations from Global Configurations are referenced in scope settings3. **Global Configurations ? Candidate Workflow**   - DSX requirements drive form field requirements   - Translations support multilingual forms4. **Customer Configurations ? Candidate Workflow**   - Customer packages determine available services for applications   - Scope settings define location-specific requirements## Implementation Status### Phase 1: Foundation (Completed)- Project setup with TypeScript and Next.js 14- Basic UI components with Shadcn/ui- Style guide creation- User authentication system setup- Initial User admin module### Phase 2: Global Configurations (Current Phase)1. ? Locations management   - ? Country table implementation   - ? Region/subregion management2. ? Services configuration   - ? Service definition and management3. ?? DSX implementation   - ?? Data fields and documents requirements4. ? Translations management   - ? Language support for UI elements### Phase 3: Customer Configurations (Upcoming)1. ?? Customer management   - ?? Customer account creation and editing   - ? Invoice settings2. ? Customer scope implementation   - ? Service package configuration   - ? Customer-specific service settings### Phase 4: Candidate Workflow (Future)1. ? Application form creation2. ? Multilingual support3. ? Workflow management## Technical IntegrationAll modules share a common technical approach:1. **Consistent UI Components**   - All modules use the same UI component library   - Consistent form and table styles   - Standard dialog implementations2. **API-First Design**   - All data access is through API endpoints   - Modules communicate via APIs   - Frontend and backend separation3. **Type Safety**   - TypeScript types shared across modules   - Consistent validation approaches   - Runtime type checking4. **Translation Support**   - All modules use the translation system   - Support for server and client components   - Dynamic language switching# Development Workflow	# Development Workflow## Development Environment Setup### Prerequisites- Node.js (v16.x or later)- pnpm package manager- Git- PostgreSQL database### Initial Setup1. Clone the repository:   ```   git clone https://github.com/your-org/globalrx.git   cd globalrx   ```2. Install dependencies:   ```   pnpm install   ```3. Set up environment variables:   ```   cp .env.example .env.local   ```   Edit `.env.local` with your database connection details and other configuration.4. Run database migrations:   ```   pnpx prisma migrate dev   ```5. Seed the database with initial data:   ```   pnpm seed   ```6. Start the development server:   ```   pnpm dev   ```The application will be available at http://localhost:3000.## Code Structure and Organization### Adding New FeaturesWhen adding new features, follow these guidelines:1. **Feature Planning**   - Define the feature requirements   - Identify the module it belongs to   - Create any necessary database schema changes2. **Implementation Approach**   - Start with database schema changes   - Create API endpoints   - Implement UI components   - Add translations for all text3. **Component Organization**   - Place module-specific components in `/src/components/modules/[module-name]/`   - Place shared UI components in `/src/components/ui/`   - Organize API routes by resource### Directory StructureMaintain the established directory structure:```/src/  /app/              # Next.js App Router routes    /[module]/       # Module-specific pages    /api/            # API routes  /components/       # React components    /modules/        # Module-specific components    /ui/             # Shared UI components  /lib/              # Utility functions  /hooks/            # React hooks  /contexts/         # React contexts  /translations/     # Translation files  /types/            # TypeScript types```## API Development### API Route StructureFollow the RESTful pattern for API routes:- `GET /api/[resource]` - List resources- `POST /api/[resource]` - Create a resource- `GET /api/[resource]/[id]` - Get a specific resource- `PUT /api/[resource]/[id]` - Update a resource- `DELETE /api/[resource]/[id]` - Delete a resource- `PATCH /api/[resource]/[id]/[action]` - Perform an action on a resource### API Implementation Example```tsx// src/app/api/users/[id]/route.tsimport { NextRequest, NextResponse } from 'next/server';import { prisma } from '@/lib/prisma';import { getServerSession } from 'next-auth';import { authOptions } from '@/lib/auth';// Get a specific userexport async function GET(  request: NextRequest,  { params }: { params: { id: string } }) {  try {    // Check authentication    const session = await getServerSession(authOptions);    if (!session) {      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });    }    // Check permissions    if (!session.user.permissions.users.view) {      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });    }    // Get user from database    const user = await prisma.user.findUnique({      where: { id: params.id },      select: {        id: true,        email: true,        firstName: true,        lastName: true,        permissions: true,        disabled: true,        createdAt: true,        updatedAt: true,      },    });    if (!user) {      return NextResponse.json({ error: 'User not found' }, { status: 404 });    }    return NextResponse.json(user);  } catch (error) {    console.error('Error getting user:', error);    return NextResponse.json(      { error: 'Failed to get user' },      { status: 500 }    );  }}// Update a userexport async function PUT(  request: NextRequest,  { params }: { params: { id: string } }) {  try {    // Check authentication    const session = await getServerSession(authOptions);    if (!session) {      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });    }    // Check permissions    if (!session.user.permissions.users.edit) {      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });    }    // Get request body    const data = await request.json();    // Update user in database    const updatedUser = await prisma.user.update({      where: { id: params.id },      data: {        firstName: data.firstName,        lastName: data.lastName,        permissions: data.permissions,      },      select: {        id: true,        email: true,        firstName: true,        lastName: true,        permissions: true,        disabled: true,        updatedAt: true,      },    });    return NextResponse.json(updatedUser);  } catch (error) {    console.error('Error updating user:', error);    return NextResponse.json(      { error: 'Failed to update user' },      { status: 500 }    );  }}```## UI Component Development### Creating a New Component1. **Plan the component**:   - Define the component's purpose and props   - Identify where it fits in the component hierarchy   - Consider reusability2. **Create the component file**:   ```tsx   // src/components/modules/[module]/MyComponent.tsx   import React from 'react';   import { useTranslation } from '@/contexts/TranslationContext';   interface MyComponentProps {     title: string;     onAction: () => void;   }   export function MyComponent({ title, onAction }: MyComponentProps) {     const { t } = useTranslation();          return (       <div className="p-4 border rounded-lg">         <h2 className="text-lg font-semibold">{title}</h2>         <p>{t('module.section.description')}</p>         <button            onClick={onAction}           className="mt-4 px-4 py-2 bg-blue-500 text-white rounded"         >           {t('common.action')}         </button>       </div>     );   }   ```3. **Add translations**:   ```json   // src/translations/en.json   {     "module.section.description": "Component description",     "common.action": "Action"   }   ```4. **Use the component**:   ```tsx   import { MyComponent } from '@/components/modules/[module]/MyComponent';   export default function Page() {     const handleAction = () => {       // Handle action     };          return (       <div>         <MyComponent            title="My Component"            onAction={handleAction}          />       </div>     );   }   ```### Using Dialogs in ComponentsAlways use the `ModalDialog` component for dialogs:```tsximport { useRef } from 'react';import { ModalDialog, DialogRef, DialogFooter } from '@/components/ui/modal-dialog';export function MyComponent() {  const dialogRef = useRef<DialogRef>(null);    const openDialog = () => {    dialogRef.current?.showModal();  };    const handleConfirm = () => {    // Perform action    dialogRef.current?.close();  };    return (    <>      <Button onClick={openDialog}>Open Dialog</Button>            <ModalDialog        ref={dialogRef}        title="Dialog Title"        footer={          <DialogFooter             onCancel={() => dialogRef.current?.close()}            onConfirm={handleConfirm}            confirmText="Confirm"          />        }      >        <div className="py-4">          Dialog content        </div>      </ModalDialog>    </>  );}```## Form Implementation### Form With ValidationUse React Hook Form with Zod for form validation:```tsximport { useForm } from 'react-hook-form';import { zodResolver } from '@hookform/resolvers/zod';import * as z from 'zod';import { FormTable, FormRow, FormActions } from '@/components/ui/form';import { Input } from '@/components/ui/input';import { Button } from '@/components/ui/button';import { StandardDropdown } from '@/components/ui/standard-dropdown';import { useTranslation } from '@/contexts/TranslationContext';// Define validation schemaconst formSchema = z.object({  name: z.string().min(1, "Name is required"),  email: z.string().email("Invalid email address"),  role: z.string().min(1, "Role is required"),});// Type inferred from schematype FormValues = z.infer<typeof formSchema>;export function UserForm({ onSubmit, initialData }) {  const { t } = useTranslation();    const {    register,    handleSubmit,    formState: { errors, isValid },    setValue,    watch,  } = useForm<FormValues>({    resolver: zodResolver(formSchema),    mode: 'onChange',    defaultValues: initialData || {      name: '',      email: '',      role: '',    },  });    // Watch values  const roleValue = watch('role');    // Role options  const roleOptions = [    { id: 'admin', value: 'admin', label: t('roles.admin') },    { id: 'manager', value: 'manager', label: t('roles.manager') },    { id: 'user', value: 'user', label: t('roles.user') },  ];    // Handle role change  const handleRoleChange = (value: string) => {    setValue('role', value, { shouldValidate: true });  };    return (    <form onSubmit={handleSubmit(onSubmit)}>      <FormTable>        <FormRow           label={t('user.form.name')}           htmlFor="name"           required={true}          error={errors.name?.message}        >          <Input            id="name"            {...register('name')}          />        </FormRow>                <FormRow           label={t('user.form.email')}           htmlFor="email"           required={true}          error={errors.email?.message}        >          <Input            id="email"            type="email"            {...register('email')}          />        </FormRow>                <FormRow           label={t('user.form.role')}           htmlFor="role"           required={true}          error={errors.role?.message}        >          <StandardDropdown            id="role"            options={roleOptions}            value={roleValue}            onChange={handleRoleChange}            placeholder={t('user.form.selectRole')}          />        </FormRow>      </FormTable>            <FormActions>        <Button           type="button"           variant="outline"           onClick={() => onCancel()}        >          {t('common.cancel')}        </Button>        <Button           type="submit"          disabled={!isValid}        >          {t('common.save')}        </Button>      </FormActions>    </form>  );}```## Testing Procedures### Manual Testing ChecklistBefore submitting code, verify:1. **Functionality**   - ? Feature works as expected   - ? Edge cases are handled   - ? Error states display properly2. **UI**   - ? Component follows styling guidelines   - ? Responsive on different screen sizes   - ? Consistent with other components3. **Forms**   - ? Validation works correctly   - ? Error messages are clear   - ? Submit/cancel buttons work properly4. **Tables**   - ? Data displays correctly   - ? Sorting/filtering works   - ? Empty states are handled5. **Dialogs**   - ? Open and close properly   - ? Backdrop prevents interaction with page   - ? ESC key closes dialog6. **Translations**   - ? All text uses translation keys   - ? Keys added to translation files   - ? Works with different languages7. **Accessibility**   - ? Proper semantic HTML   - ? Keyboard navigation works   - ? Screen reader friendly### Automated Testing (Future)Plans for automated testing include:1. **Unit Tests**: For utility functions and hooks2. **Component Tests**: For UI components3. **API Tests**: For API endpoints4. **End-to-End Tests**: For critical user flows## Deployment Process### Development Deployment1. Code is pushed to the `develop` branch2. CI/CD pipeline runs tests3. Automatic deployment to development environment### Staging Deployment1. Code is merged from `develop` to `staging`2. CI/CD pipeline runs tests3. Automatic deployment to staging environment for testing### Production Deployment1. Code is merged from `staging` to `main`2. CI/CD pipeline runs tests3. Manual approval step4. Deployment to production environment## Versioning and Release Management### VersioningWe follow semantic versioning (semver):- **Major version** (1.0.0): Breaking changes- **Minor version** (0.1.0): New features, no breaking changes- **Patch version** (0.0.1): Bug fixes, no new features### Release Schedule- **Patch releases**: As needed for critical fixes- **Minor releases**: Every 2-4 weeks- **Major releases**: Scheduled based on roadmap### Release NotesFor each release, create detailed release notes:- New features- Bug fixes- Performance improvements- API changes- Migration instructions (if applicable)# Security and Authentication# Security and Authentication## Authentication SystemThe GlobalRx platform implements a robust authentication system using NextAuth.js to secure access to the application and its resources.### Authentication Flow1. **Login Process**   - User enters email and password   - Credentials are validated against the database   - BCrypt is used for password hashing   - Upon successful authentication, a session is created2. **Session Management**   - Sessions are stored server-side with a client cookie reference   - Session expiration is set to 24 hours   - Sessions include user ID, email, and basic permissions3. **Route Protection**   - Server-side route protection in API routes   - Client-side route protection using an auth interceptor   - Unauthorized access redirects to the login page### Role-Based Access ControlThe platform implements fine-grained permissions through a structured RBAC system:```typescript// Permission structureinterface Permissions {  users: {    view: boolean;    create: boolean;    edit: boolean;    delete: boolean;  };  countries: {    view: boolean;    manage: boolean;  };  services: {    view: boolean;    manage: boolean;  };  dsx: {    view: boolean;    manage: boolean;  };  customers: {    view: boolean;    create: boolean;    edit: boolean;    all: boolean; // Access to all customers, otherwise limited to assigned  };}```### Implementation Details#### Auth Context Provider```tsx// src/contexts/AuthContext.tsximport { createContext, useContext, useState, useEffect } from 'react';import { useSession, signIn, signOut } from 'next-auth/react';const AuthContext = createContext({  isAuthenticated: false,  user: null,  permissions: {},  loading: true,  login: async (email: string, password: string) => ({ success: false, error: '' }),  logout: async () => {},  checkPermission: (resource: string, action: string) => false,});export function AuthProvider({ children }) {  const { data: session, status } = useSession();  const [loading, setLoading] = useState(true);  useEffect(() => {    setLoading(status === 'loading');  }, [status]);  const login = async (email: string, password: string) => {    try {      const result = await signIn('credentials', {        redirect: false,        email,        password,      });      return {        success: !result?.error,        error: result?.error || '',      };    } catch (error) {      return {        success: false,        error: 'Failed to login',      };    }  };  const logout = async () => {    await signOut({ redirect: false });  };  const checkPermission = (resource: string, action: string) => {    if (!session?.user?.permissions) return false;        const resourcePermissions = session.user.permissions[resource];    if (!resourcePermissions) return false;        return !!resourcePermissions[action];  };  return (    <AuthContext.Provider      value={{        isAuthenticated: !!session?.user,        user: session?.user || null,        permissions: session?.user?.permissions || {},        loading,        login,        logout,        checkPermission,      }}    >      {children}    </AuthContext.Provider>  );}export const useAuth = () => useContext(AuthContext);```#### API Route Protection```typescript// src/app/api/protected-resource/route.tsimport { NextRequest, NextResponse } from 'next/server';import { getServerSession } from 'next-auth';import { authOptions } from '@/lib/auth';export async function GET(request: NextRequest) {  // Check authentication  const session = await getServerSession(authOptions);  if (!session) {    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });  }    // Check permissions  if (!session.user.permissions.resource.view) {    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });  }    // Process authorized request  // ...}```#### Auth Interceptor Component```tsx// src/components/auth/auth-interceptor.tsx'use client';import { useEffect, useState } from 'react';import { useRouter, usePathname } from 'next/navigation';import { useSession } from 'next-auth/react';import { LoadingSpinner } from '@/components/ui/loading-spinner';const PUBLIC_PATHS = ['/login', '/forgot-password'];export function AuthInterceptor({ children }) {  const { data: session, status } = useSession();  const router = useRouter();  const pathname = usePathname();  const [isAuthorized, setIsAuthorized] = useState(false);    useEffect(() => {    // Allow access to public paths    if (PUBLIC_PATHS.includes(pathname)) {      setIsAuthorized(true);      return;    }        // Check authentication    if (status === 'loading') {      setIsAuthorized(false);      return;    }        if (!session) {      router.push(`/login?returnUrl=${encodeURIComponent(pathname)}`);      return;    }        // Perform any additional permission checks here    // ...        setIsAuthorized(true);  }, [session, status, pathname, router]);    if (!isAuthorized) {    return (      <div className="flex justify-center items-center min-h-screen">        <LoadingSpinner size="lg" />      </div>    );  }    return children;}```## Security Measures### Password Policies1. **Password Requirements**:   - Minimum length: 8 characters   - Must include at least one number   - Must include at least one uppercase letter   - Must include at least one special character2. **Password Storage**:   - Passwords are never stored in plaintext   - BCrypt with a work factor of 12 is used for hashing   - Password reset tokens use a separate mechanism with time-limited validity### CSRF Protection1. NextAuth.js includes built-in CSRF protection2. All state-changing operations use POST/PUT/DELETE methods3. API routes validate the origin of requests### API Security1. **Rate Limiting**:   - API endpoints implement rate limiting to prevent abuse   - Login endpoints have stricter rate limits to prevent brute force attacks2. **Input Validation**:   - All API inputs are validated using Zod schemas   - Validation occurs both client-side and server-side3. **Output Sanitization**:   - Sensitive data is filtered from API responses   - User data is sanitized to prevent XSS attacks### Security HeadersThe application implements security headers using the Next.js configuration:```javascript// next.config.jsconst securityHeaders = [  {    key: 'X-DNS-Prefetch-Control',    value: 'on',  },  {    key: 'Strict-Transport-Security',    value: 'max-age=63072000; includeSubDomains; preload',  },  {    key: 'X-XSS-Protection',    value: '1; mode=block',  },  {    key: 'X-Frame-Options',    value: 'SAMEORIGIN',  },  {    key: 'X-Content-Type-Options',    value: 'nosniff',  },  {    key: 'Referrer-Policy',    value: 'strict-origin-when-cross-origin',  },];module.exports = {  // ...other config  async headers() {    return [      {        source: '/:path*',        headers: securityHeaders,      },    ];  },};```## Data Protection### Sensitive Data Handling1. **PII Management**:   - Personal Identifiable Information (PII) is clearly identified in the data model   - Access to PII is restricted based on user permissions   - PII is masked in logs and non-essential displays2. **Data Minimization**:   - Only necessary data is collected and stored   - Automatic data purging for inactive accounts   - Clear data retention policies### Audit LoggingThe platform implements comprehensive audit logging:```typescript// Example audit log creationasync function createAuditLog(userId: string, action: string, resourceType: string, resourceId: string, details?: any) {  await prisma.auditLog.create({    data: {      userId,      action,      resourceType,      resourceId,      details: details ? JSON.stringify(details) : null,      ipAddress: request.headers.get('x-forwarded-for') || 'unknown',      userAgent: request.headers.get('user-agent') || 'unknown',    },  });}```Audit logs capture:1. Who performed the action (user ID)2. What action was performed (create, update, delete)3. Which resource was affected (type and ID)4. When the action occurred (timestamp)5. Additional context (request details)## Secure Coding Practices### Preventing Common Vulnerabilities1. **SQL Injection**: Using Prisma ORM with parameterized queries2. **XSS (Cross-Site Scripting)**: Proper output encoding and React's inherent protection3. **CSRF (Cross-Site Request Forgery)**: NextAuth.js built-in protection4. **Insecure Direct Object References**: Proper authorization checks on all resources5. **Broken Authentication**: Secure session management via NextAuth.js### Dependency Management1. Regular security audits with `pnpm audit`2. Automated vulnerability scanning in CI/CD pipeline3. Dependency update strategy for security patches## Environment-Specific Security### Development- Use of environment variables for configuration- No real credentials in development environment- Local database with synthetic data### Staging- Isolated environment with separate credentials- Full security measures implemented- Regular security testing### Production- Strict security policies enforced- Regular security audits and penetration testing- Monitoring for suspicious activities## Security Incident Response1. **Detection**:   - Automated monitoring for suspicious activities   - Regular log analysis   - User-reported issues2. **Containment**:   - Immediate isolation of affected components   - Temporary account suspension if necessary   - Blocking of suspicious IP addresses3. **Eradication**:   - Identification and removal of the root cause   - Patching of vulnerabilities   - Verification of system integrity4. **Recovery**:   - Restoration of affected systems   - Validation of security controls   - Gradual return to normal operations5. **Lessons Learned**:   - Documentation of the incident   - Review of security measures   - Implementation of preventive controls# Error Handling# Error Handling## Error Handling StrategyThe GlobalRx application implements a comprehensive error handling strategy to ensure a reliable user experience and maintainable codebase.### Core Principles1. **Graceful Degradation**: The application should continue to function even when errors occur2. **User-Friendly Messaging**: Error messages should be clear and actionable for users3. **Detailed Logging**: Technical details should be logged for debugging4. **Consistent Patterns**: Error handling should follow consistent patterns throughout the application## Frontend Error Handling### React Error BoundariesThe application uses React Error Boundaries to catch and handle errors in the component tree:```tsx// src/components/error-boundary.tsx'use client';import React, { Component, ErrorInfo, ReactNode } from 'react';import { Button } from '@/components/ui/button';interface ErrorBoundaryProps {  children: ReactNode;  fallback?: ReactNode;}interface ErrorBoundaryState {  hasError: boolean;  error: Error | null;}export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {  constructor(props: ErrorBoundaryProps) {    super(props);    this.state = {      hasError: false,      error: null,    };  }  static getDerivedStateFromError(error: Error): ErrorBoundaryState {    return {      hasError: true,      error,    };  }  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {    // Log the error to an error reporting service    console.error('Error caught by ErrorBoundary:', error, errorInfo);        // Here you would typically log to a service like Sentry    // logErrorToService(error, errorInfo);  }  resetError = () => {    this.setState({      hasError: false,      error: null,    });  };  render() {    if (this.state.hasError) {      // Use the provided fallback or default to our own      if (this.props.fallback) {        return this.props.fallback;      }      return (        <div className="p-6 rounded-lg border border-red-200 bg-red-50">          <h2 className="text-xl font-semibold text-red-700 mb-4">            Something went wrong          </h2>          <p className="mb-4 text-red-600">            An error occurred while rendering this component.          </p>          {this.state.error && (            <div className="p-3 bg-white rounded border border-red-100 mb-4 font-mono text-sm overflow-x-auto">              {this.state.error.toString()}            </div>          )}          <Button onClick={this.resetError}>Try Again</Button>        </div>      );    }    return this.props.children;  }}```### Page-Level Error HandlingEvery page should have its own error handling using Next.js error components:```tsx// src/app/[module]/error.tsx'use client';import { useEffect } from 'react';import { Button } from '@/components/ui/button';export default function ModuleError({  error,  reset,}: {  error: Error & { digest?: string };  reset: () => void;}) {  useEffect(() => {    // Log the error to an error reporting service    console.error('Page-level error:', error);  }, [error]);  return (    <div className="flex flex-col items-center justify-center min-h-screen p-4">      <div className="w-full max-w-md p-6 rounded-lg border border-red-200 bg-red-50">        <h2 className="text-2xl font-semibold text-red-700 mb-4">          Something went wrong        </h2>        <p className="mb-6 text-red-600">          We encountered an error while loading this page. Please try again or contact support if the problem persists.        </p>        <div className="flex space-x-4">          <Button onClick={reset} variant="default">            Try Again          </Button>          <Button             onClick={() => window.location.href = '/'}            variant="outline"          >            Go Home          </Button>        </div>      </div>    </div>  );}```### API Error Handling in ComponentsUse a consistent pattern for handling API errors in components:```tsx// Example component with API error handling'use client';import { useState, useEffect } from 'react';import { useAuth } from '@/components/auth/auth-interceptor';import { Button } from '@/components/ui/button';import { LoadingIndicator } from '@/components/ui/loading-indicator';import { AlertBox } from '@/components/ui/alert-box';export function DataDisplay() {  const [data, setData] = useState([]);  const [isLoading, setIsLoading] = useState(true);  const [error, setError] = useState<string | null>(null);  const { fetchWithAuth } = useAuth();  const fetchData = async () => {    try {      setIsLoading(true);      setError(null);            const response = await fetchWithAuth('/api/data');            if (!response.ok) {        // Handle HTTP error statuses        if (response.status === 404) {          throw new Error('The requested data could not be found.');        } else if (response.status === 403) {          throw new Error('You do not have permission to access this data.');        } else {          const errorData = await response.json().catch(() => ({}));          throw new Error(errorData.error || `Failed to fetch data: ${response.status}`);        }      }            const data = await response.json();      setData(data);    } catch (err) {      console.error('Error fetching data:', err);      setError(err instanceof Error ? err.message : 'An unknown error occurred');    } finally {      setIsLoading(false);    }  };  useEffect(() => {    fetchData();  }, []);  if (isLoading) {    return <LoadingIndicator />;  }  if (error) {    return (      <AlertBox         type="error"         title="Error Loading Data"        message={error}        action={          <Button onClick={fetchData}>Retry</Button>        }      />    );  }  return (    <div>      {/* Render data */}    </div>  );}```### Form Error HandlingFor form validation errors, use a consistent approach with React Hook Form and Zod:```tsx// Form with validation error handlingimport { useForm } from 'react-hook-form';import { zodResolver } from '@hookform/resolvers/zod';import * as z from 'zod';import { useState } from 'react';import { FormTable, FormRow, FormActions } from '@/components/ui/form';import { Input } from '@/components/ui/input';import { Button } from '@/components/ui/button';import { AlertBox } from '@/components/ui/alert-box';// Define validation schemaconst formSchema = z.object({  name: z.string().min(1, "Name is required"),  email: z.string().email("Invalid email address"),});type FormValues = z.infer<typeof formSchema>;export function UserForm({ onSubmit }) {  const [submitError, setSubmitError] = useState<string | null>(null);  const [isSubmitting, setIsSubmitting] = useState(false);    const {    register,    handleSubmit,    formState: { errors },  } = useForm<FormValues>({    resolver: zodResolver(formSchema),  });    const handleFormSubmit = async (data: FormValues) => {    try {      setIsSubmitting(true);      setSubmitError(null);            await onSubmit(data);    } catch (error) {      console.error('Form submission error:', error);      setSubmitError(        error instanceof Error           ? error.message           : 'An error occurred while submitting the form.'      );    } finally {      setIsSubmitting(false);    }  };    return (    <form onSubmit={handleSubmit(handleFormSubmit)}>      {submitError && (        <AlertBox           type="error"          title="Submission Error"          message={submitError}          className="mb-6"        />      )}            <FormTable>        <FormRow           label="Name"           htmlFor="name"           required={true}          error={errors.name?.message}        >          <Input id="name" {...register('name')} />        </FormRow>                <FormRow           label="Email"           htmlFor="email"           required={true}          error={errors.email?.message}        >          <Input id="email" type="email" {...register('email')} />        </FormRow>      </FormTable>            <FormActions>        <Button type="submit" disabled={isSubmitting}>          {isSubmitting ? 'Submitting...' : 'Submit'}        </Button>      </FormActions>    </form>  );}```## Backend Error Handling### API Route Error HandlingAll API routes should follow a consistent error handling pattern:```tsx// src/app/api/resource/route.tsimport { NextRequest, NextResponse } from 'next/server';import { getServerSession } from 'next-auth';import { authOptions } from '@/lib/auth';import { prisma } from '@/lib/prisma';import { z } from 'zod';// Validation schemaconst resourceSchema = z.object({  name: z.string().min(1),  description: z.string().optional(),});export async function POST(request: NextRequest) {  try {    // Authentication check    const session = await getServerSession(authOptions);    if (!session) {      return NextResponse.json(        { error: 'Unauthorized' },        { status: 401 }      );    }    // Permission check    if (!session.user.permissions.resource.create) {      return NextResponse.json(        { error: 'Forbidden' },        { status: 403 }      );    }    // Parse and validate request body    const body = await request.json().catch(() => ({}));        const validationResult = resourceSchema.safeParse(body);    if (!validationResult.success) {      return NextResponse.json(        {           error: 'Invalid request data',          details: validationResult.error.format()         },        { status: 400 }      );    }    const data = validationResult.data;    // Process request    try {      const resource = await prisma.resource.create({        data: {          name: data.name,          description: data.description || null,          createdById: session.user.id,        },      });      return NextResponse.json(resource, { status: 201 });    } catch (dbError) {      console.error('Database error:', dbError);            // Handle specific database errors      if (dbError.code === 'P2002') {        return NextResponse.json(          { error: 'A resource with this name already exists' },          { status: 409 }        );      }            throw dbError; // Re-throw for general error handling    }  } catch (error) {    console.error('Error in resource creation:', error);        return NextResponse.json(      { error: 'An error occurred while processing your request' },      { status: 500 }    );  }}```### Custom Error ClassesDefine custom error classes for specific error scenarios:```typescript// src/lib/errors.tsexport class AppError extends Error {  statusCode: number;  code: string;    constructor(message: string, statusCode: number = 500, code: string = 'INTERNAL_ERROR') {    super(message);    this.name = this.constructor.name;    this.statusCode = statusCode;    this.code = code;    Error.captureStackTrace(this, this.constructor);  }}export class ValidationError extends AppError {  details: any;    constructor(message: string, details: any) {    super(message, 400, 'VALIDATION_ERROR');    this.details = details;  }}export class NotFoundError extends AppError {  constructor(resource: string, id?: string) {    const message = id       ? `${resource} with ID ${id} not found`      : `${resource} not found`;    super(message, 404, 'NOT_FOUND');  }}export class AuthorizationError extends AppError {  constructor(message: string = 'You do not have permission to perform this action') {    super(message, 403, 'FORBIDDEN');  }}export class AuthenticationError extends AppError {  constructor(message: string = 'Authentication required') {    super(message, 401, 'UNAUTHORIZED');  }}```### Error MiddlewareCreate an error handling middleware for API routes:```typescript// src/lib/error-middleware.tsimport { NextRequest, NextResponse } from 'next/server';import { AppError, ValidationError } from '@/lib/errors';export async function withErrorHandling(  handler: (req: NextRequest) => Promise<NextResponse>,  req: NextRequest) {  try {    return await handler(req);  } catch (error) {    console.error('API Error:', error);        // Handle known error types    if (error instanceof AppError) {      return NextResponse.json(        {           error: error.message,          code: error.code,          ...(error instanceof ValidationError ? { details: error.details } : {})        },        { status: error.statusCode }      );    }        // Handle unexpected errors    return NextResponse.json(      { error: 'An unexpected error occurred', code: 'INTERNAL_ERROR' },      { status: 500 }    );  }}// Usage in API routeexport async function GET(request: NextRequest) {  return withErrorHandling(async (req) => {    // Route handler code...    // Can throw AppError subclasses directly        return NextResponse.json(result);  }, request);}```## Error Logging and Monitoring### Client-Side Error Logging```typescript// src/lib/error-logger.tsinterface ErrorLogData {  message: string;  stack?: string;  componentName?: string;  url?: string;  userId?: string;  additionalData?: any;}export async function logErrorToServer(error: Error, additionalData: any = {}) {  try {    const logData: ErrorLogData = {      message: error.message,      stack: error.stack,      url: window.location.href,      additionalData    };        // Send to logging endpoint    await fetch('/api/logs/error', {      method: 'POST',      headers: {        'Content-Type': 'application/json',      },      body: JSON.stringify(logData),    });  } catch (logError) {    // Fallback to console in case sending fails    console.error('Failed to log error to server:', logError);    console.error('Original error:', error);  }}```### Server-Side Error Logging```typescript// src/lib/server-logger.tsinterface ServerErrorLog {  message: string;  stack?: string;  path?: string;  method?: string;  userId?: string;  timestamp: Date;  severity: 'info' | 'warn' | 'error' | 'fatal';  additionalData?: any;}export async function logServerError(  error: Error,   request?: NextRequest,   userId?: string,  additionalData?: any) {  const errorLog: ServerErrorLog = {    message: error.message,    stack: error.stack,    path: request?.nextUrl.pathname,    method: request?.method,    userId,    timestamp: new Date(),    severity: 'error',    additionalData  };    // Log to console in development  if (process.env.NODE_ENV === 'development') {    console.error('Server Error:', errorLog);  }    // In production, you would send this to a logging service  // Such as CloudWatch, Datadog, or a dedicated logging database    // For now, save to database  try {    await prisma.errorLog.create({      data: {        message: errorLog.message,        stack: errorLog.stack,        path: errorLog.path,        method: errorLog.method,        userId: errorLog.userId,        severity: errorLog.severity,        additionalData: additionalData ? JSON.stringify(additionalData) : null,      },    });  } catch (logError) {    // Fallback if database logging fails    console.error('Failed to log error to database:', logError);    console.error('Original error:', error);  }}```## User-Facing Error Messages### Error Message Guidelines1. **Be Specific**: Provide specific information about what went wrong2. **Be Actionable**: Tell the user what they can do to resolve the issue3. **Be Respectful**: Don't blame the user or use technical jargon4. **Be Consistent**: Use consistent error formatting throughout the application### Common Error Messages| Scenario | Bad Example | Good Example ||----------|-------------|--------------|| Invalid Form Input | "Validation failed" | "Please enter a valid email address" || Authentication Error | "Auth error 401" | "Your session has expired. Please log in again." || Permission Error | "Access denied" | "You don't have permission to perform this action. Please contact your administrator." || Network Error | "Failed to fetch" | "Unable to connect to the server. Please check your internet connection and try again." || Server Error | "Internal server error" | "Something went wrong on our end. We've logged the issue and will fix it soon. Please try again later." |### Error Display ComponentsCreate reusable error display components:```tsx// src/components/ui/alert-box.tsximport React from 'react';import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';import { AlertCircle, AlertTriangle, Info, CheckCircle } from 'lucide-react';type AlertType = 'error' | 'warning' | 'info' | 'success';interface AlertBoxProps {  type: AlertType;  title: string;  message: string;  action?: React.ReactNode;  className?: string;}export function AlertBox({ type, title, message, action, className = '' }: AlertBoxProps) {  const iconMap = {    error: <AlertCircle className="h-5 w-5 text-red-500" />,    warning: <AlertTriangle className="h-5 w-5 text-amber-500" />,    info: <Info className="h-5 w-5 text-blue-500" />,    success: <CheckCircle className="h-5 w-5 text-green-500" />,  };  const bgColorMap = {    error: 'bg-red-50 border-red-200',    warning: 'bg-amber-50 border-amber-200',    info: 'bg-blue-50 border-blue-200',    success: 'bg-green-50 border-green-200',  };  const textColorMap = {    error: 'text-red-800',    warning: 'text-amber-800',    info: 'text-blue-800',    success: 'text-green-800',  };  return (    <Alert       className={`${bgColorMap[type]} ${className} border`}    >      <div className="flex">        <div className="flex-shrink-0">          {iconMap[type]}        </div>        <div className="ml-3 flex-1">          <AlertTitle className={`text-sm font-medium ${textColorMap[type]}`}>            {title}          </AlertTitle>          <AlertDescription className={`mt-2 text-sm ${textColorMap[type]}`}>            {message}          </AlertDescription>          {action && (            <div className="mt-4">              {action}            </div>          )}        </div>      </div>    </Alert>  );}```## Error Recovery Strategies### Form Recovery1. **Save Form State**: Use local storage to save form state for recovery2. **Autosave**: Implement autosave for long forms3. **Optimistic Updates**: Display success UI immediately but revert on failure### Network Resilience1. **Retry Logic**: Automatically retry failed requests with exponential backoff2. **Offline Support**: Queue operations when offline and sync when connection is restored3. **Graceful Degradation**: Provide read-only functionality when write operations fail### Session Recovery1. **Session Renewal**: Automatically renew expired sessions2. **Graceful Redirects**: Redirect to login with return URL when session expires3. **Application State Preservation**: Store application state to restore after login# Performance Optimization# Performance Optimization## Performance FundamentalsThe GlobalRx application prioritizes performance to ensure a responsive and efficient user experience, even as the application scales with more data and users.### Key Performance Indicators (KPIs)1. **Time to First Byte (TTFB)**: < 200ms2. **First Contentful Paint (FCP)**: < 1.0s3. **Largest Contentful Paint (LCP)**: < 2.5s4. **First Input Delay (FID)**: < 100ms5. **Cumulative Layout Shift (CLS)**: < 0.16. **Time to Interactive (TTI)**: < 3.5s### Monitoring Performance- Regular performance audits using Lighthouse- Real User Monitoring (RUM) to track actual user experience- Server response time monitoring- Database query performance tracking## Frontend Optimization### Component Optimization#### Code SplittingLeverage Next.js's built-in code splitting features:```tsx// Dynamic imports for large componentsimport dynamic from 'next/dynamic';// Only load this component when neededconst HeavyComponent = dynamic(() => import('@/components/heavy-component'), {  loading: () => <LoadingPlaceholder />,  ssr: false // Disable Server-Side Rendering if not needed});```#### React Component Optimization1. **Memoization**: Use React.memo, useMemo, and useCallback to prevent unnecessary re-renders:```tsx// Memoize expensive componentsconst MemoizedComponent = React.memo(MyComponent);// Memoize expensive calculationsconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);// Memoize callbacksconst memoizedCallback = useCallback(() => {  doSomethingWith(a, b);}, [a, b]);```2. **State Management**: Keep state as local as possible:```tsx// Bad: Global state for everythingconst [globalState, setGlobalState] = useState({  userDetails: {},  preferences: {},  tableData: [],  filterSettings: {},});// Good: Split state by concern and keep it localfunction UserProfile() {  const [userDetails, setUserDetails] = useState({});  // ...}function DataTable() {  const [tableData, setTableData] = useState([]);  const [filterSettings, setFilterSettings] = useState({});  // ...}```### Rendering Optimization#### Server ComponentsLeverage Next.js 14 Server Components for improved performance:```tsx// src/app/dashboard/page.tsx// This is a Server Component by default in App Routerexport default async function DashboardPage() {  // Data fetching happens on the server  const data = await fetchDashboardData();    return (    <div>      <h1>Dashboard</h1>      {/* Render data-heavy components on the server */}      <DashboardSummary data={data.summary} />      <RecentActivityTable activities={data.activities} />            {/* Client interactivity where needed */}      <ClientInteractiveWidget />    </div>  );}// src/components/client-interactive-widget.tsx'use client';export function ClientInteractiveWidget() {  // Client-side interactivity here}```#### Virtualization for Long ListsUse virtualization for long lists or tables:```tsx// src/components/virtualized-table.tsx'use client';import { useVirtualizer } from '@tanstack/react-virtual';import { useRef } from 'react';export function VirtualizedTable({ data }) {  const parentRef = useRef<HTMLDivElement>(null);    const virtualizer = useVirtualizer({    count: data.length,    getScrollElement: () => parentRef.current,    estimateSize: () => 35, // Estimated row height    overscan: 10, // Number of items to render outside of view  });    return (    <div       ref={parentRef}       className="h-[500px] overflow-auto"    >      <table className="w-full">        <thead>          <tr>            <th>ID</th>            <th>Name</th>            <th>Status</th>          </tr>        </thead>        <tbody>          {/* Set the total height */}          <div             style={{               height: `${virtualizer.getTotalSize()}px`,              position: 'relative',            }}          >            {virtualizer.getVirtualItems().map((virtualRow) => {              const item = data[virtualRow.index];              return (                <tr                  key={item.id}                  style={{                    position: 'absolute',                    top: 0,                    left: 0,                    width: '100%',                    transform: `translateY(${virtualRow.start}px)`,                  }}                >                  <td>{item.id}</td>                  <td>{item.name}</td>                  <td>{item.status}</td>                </tr>              );            })}          </div>        </tbody>      </table>    </div>  );}```### Image OptimizationLeverage Next.js Image component for optimized images:```tsximport Image from 'next/image';export function OptimizedImage() {  return (    <div className="relative h-40 w-40">      <Image        src="/profile.jpg"        alt="Profile picture"        fill        sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"        priority={false}        loading="lazy"        className="object-cover"      />    </div>  );}```### Asset Optimization1. **Leverage Static Generation**: Use static generation for suitable pages2. **CSS Optimization**: Use Tailwind's built-in purging to minimize CSS3. **Font Optimization**: Use next/font for optimized font loading with zero layout shift```tsx// In layout.tsximport { Inter } from 'next/font/google';// Configure font for optimal loadingconst inter = Inter({  subsets: ['latin'],  display: 'swap',  preload: true,  // Variable fonts or specific weights  // weight: ['400', '500', '600', '700'],});export default function RootLayout({ children }) {  return (    <html lang="en" className={inter.className}>      <body>{children}</body>    </html>  );}```## Backend Optimization### API Route Optimization#### Response CachingImplement API response caching using Next.js Cache:```typescript// src/app/api/cached-data/route.tsimport { NextRequest, NextResponse } from 'next/server';import { revalidatePath } from 'next/cache';// Define cache configurationexport const dynamic = 'force-dynamic';export const revalidate = 3600; // Cache for 1 hourexport async function GET(request: NextRequest) {  // Expensive data fetching  const data = await fetchExpensiveData();    // Set cache headers  const response = NextResponse.json(data);  response.headers.set('Cache-Control', 'max-age=3600, s-maxage=3600, stale-while-revalidate=86400');    return response;}// Function to manually invalidate cacheexport async function POST(request: NextRequest) {  const { path } = await request.json();    // Revalidate the path  revalidatePath(path);    return NextResponse.json({ revalidated: true });}```#### Request BatchingImplement batch endpoints for multiple operations:```typescript// src/app/api/batch/route.tsimport { NextRequest, NextResponse } from 'next/server';export async function POST(request: NextRequest) {  try {    const { operations } = await request.json();        // Process operations in parallel    const results = await Promise.all(      operations.map(async (operation) => {        try {          // Process each operation          const result = await processOperation(operation);          return { success: true, result };        } catch (error) {          return {             success: false,             error: error.message           };        }      })    );        return NextResponse.json({ results });  } catch (error) {    return NextResponse.json(      { error: 'Failed to process batch operations' },      { status: 500 }    );  }}async function processOperation(operation) {  const { type, data } = operation;    switch (type) {    case 'get':      return await fetchData(data.resource, data.id);    case 'create':      return await createResource(data.resource, data.payload);    case 'update':      return await updateResource(data.resource, data.id, data.payload);    case 'delete':      return await deleteResource(data.resource, data.id);    default:      throw new Error(`Unknown operation type: ${type}`);  }}```### Database Optimization#### Prisma Query Optimization1. **Select Only Needed Fields**:```typescript// Bad: Select all fieldsconst user = await prisma.user.findUnique({  where: { id },});// Good: Select only needed fieldsconst user = await prisma.user.findUnique({  where: { id },  select: {    id: true,    name: true,    email: true,  },});```2. **Use Pagination for Large Results**:```typescript// Bad: Fetch all recordsconst allUsers = await prisma.user.findMany();// Good: Use paginationconst paginatedUsers = await prisma.user.findMany({  skip: (page - 1) * pageSize,  take: pageSize,});```3. **Optimize Relations**:```typescript// Bad: N+1 problemconst users = await prisma.user.findMany();for (const user of users) {  const posts = await prisma.post.findMany({    where: { authorId: user.id },  });  user.posts = posts;}// Good: Include related dataconst usersWithPosts = await prisma.user.findMany({  include: {    posts: true,  },});```#### Database IndexingEnsure proper indexes are defined in the Prisma schema:```prismamodel User {  id        String   @id @default(uuid())  email     String   @unique  name      String  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  // Add index for frequently searched fields  @@index([name])}model Post {  id        String   @id @default(uuid())  title     String  content   String?  published Boolean  @default(false)  authorId  String  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt    author    User     @relation(fields: [authorId], references: [id])  // Add compound index for filtering published posts by author  @@index([authorId, published])}```## Network Optimization### Data Fetching Strategies#### SWR for Client-Side Data FetchingUse SWR for client components that need to fetch data:```tsx// src/components/data-display.tsx'use client';import useSWR from 'swr';import { LoadingIndicator } from '@/components/ui/loading-indicator';import { AlertBox } from '@/components/ui/alert-box';// Define fetcher functionconst fetcher = async (url) => {  const response = await fetch(url);    if (!response.ok) {    throw new Error('Failed to fetch data');  }    return response.json();};export function DataDisplay() {  const { data, error, isLoading, mutate } = useSWR('/api/data', fetcher, {    revalidateOnFocus: false,    revalidateOnReconnect: true,    dedupingInterval: 10000,  });  if (isLoading) {    return <LoadingIndicator />;  }  if (error) {    return (      <AlertBox         type="error"         title="Error Loading Data"        message={error.message}        action={          <Button onClick={() => mutate()}>Retry</Button>        }      />    );  }  return (    <div>      {/* Render data */}    </div>  );}```#### Parallel Data FetchingFetch data in parallel when possible:```tsx// Sequential fetching (slower)const userData = await fetchUserData(userId);const postsData = await fetchUserPosts(userId);const statsData = await fetchUserStats(userId);// Parallel fetching (faster)const [userData, postsData, statsData] = await Promise.all([  fetchUserData(userId),  fetchUserPosts(userId),  fetchUserStats(userId),]);```### Response Size Optimization#### CompressionEnsure responses are compressed using Next.js compression middleware:```typescript// next.config.jsmodule.exports = {  compress: true, // Enable compression};```#### GraphQL for Flexible Data RequirementsFor complex data requirements, consider adding a GraphQL API:```typescript// src/app/api/graphql/route.tsimport { createYoga } from 'graphql-yoga';import { schema } from '@/lib/graphql/schema';// Create a Yoga instance with Next.js API route configconst { handleRequest } = createYoga({  schema,  graphqlEndpoint: '/api/graphql',  fetchAPI: { Response },});export { handleRequest as GET, handleRequest as POST };```This allows clients to request only the data they need:```graphqlquery GetUserWithSpecificFields {  user(id: "123") {    id    name    email    # Only include posts if needed    posts {      id      title      # Don't include content if not needed    }  }}```## Monitoring and Profiling### Client-Side Performance MonitoringImplement Web Vitals reporting:```tsx// src/app/layout.tsx'use client';import { useReportWebVitals } from 'next/web-vitals';export function WebVitalsReporter() {  useReportWebVitals(metric => {    console.log(metric);        // Send to analytics service    sendToAnalytics({      name: metric.name,      value: metric.value,      id: metric.id,    });  });    return null;}export default function RootLayout({ children }) {  return (    <html lang="en">      <head />      <body>        <WebVitalsReporter />        {children}      </body>    </html>  );}```### Component ProfilingUse React Profiler to identify performance bottlenecks:```tsx// src/components/profiled-component.tsx'use client';import { Profiler } from 'react';function onRenderCallback(  id, // the "id" prop of the Profiler tree that has just committed  phase, // either "mount" (if the tree just mounted) or "update" (if it re-rendered)  actualDuration, // time spent rendering the committed update  baseDuration, // estimated time to render the entire subtree without memoization  startTime, // when React began rendering this update  commitTime, // when React committed this update  interactions // the Set of interactions belonging to this update) {  // Log performance metrics  console.log({    id,    phase,    actualDuration,    baseDuration,    startTime,    commitTime,  });    // Record if render took too long  if (actualDuration > 16) { // More than 1 frame (60 fps)    recordLongRender({      id,      actualDuration,      component: id,    });  }}export function ProfiledComponent({ children }) {  return (    <Profiler id="MyComponent" onRender={onRenderCallback}>      {children}    </Profiler>  );}```## Lazy Loading and Prefetching### Route-Based PrefetchingLeverage Next.js Link component for intelligent prefetching:```tsx// src/components/nav-link.tsximport Link from 'next/link';export function NavLink({ href, children }) {  return (    <Link       href={href}      prefetch={true} // Default behavior - prefetches on viewport entry    >      {children}    </Link>  );}```### Manual PrefetchingFor important future interactions, manually prefetch data:```tsx'use client';import { useEffect } from 'react';import { useRouter } from 'next/navigation';export function DashboardLayout({ children }) {  const router = useRouter();    useEffect(() => {    // Prefetch likely next pages    router.prefetch('/dashboard/profile');    router.prefetch('/dashboard/settings');        // Prefetch important API data    const prefetchData = async () => {      // Fetch data in the background      await fetch('/api/dashboard/summary');    };        prefetchData();  }, [router]);    return (    <div className="dashboard-layout">      {/* Navigation */}      <div className="dashboard-content">        {children}      </div>    </div>  );}```## Progressive Enhancement### Loading StatesImplement progressive loading states for better perceived performance:```tsx// src/app/dashboard/page.tsximport { Suspense } from 'react';import { DashboardSkeleton } from '@/components/skeletons/dashboard-skeleton';import { DashboardContent } from '@/components/dashboard/dashboard-content';export default function DashboardPage() {  return (    <div>      <h1>Dashboard</h1>            {/* Show skeleton immediately while content loads */}      <Suspense fallback={<DashboardSkeleton />}>        <DashboardContent />      </Suspense>    </div>  );}```### Incremental LoadingLoad critical content first, then non-critical content:```tsx// src/components/dashboard/dashboard-content.tsx'use client';import { useState, useEffect } from 'react';import { SummaryCards } from './summary-cards';import { RecentActivity } from './recent-activity';import { DetailedReports } from './detailed-reports';export function DashboardContent() {  const [summaryData, setSummaryData] = useState(null);  const [activityData, setActivityData] = useState(null);  const [reportsData, setReportsData] = useState(null);    // Load data in priority order  useEffect(() => {    // Load critical data first    fetchSummaryData().then(setSummaryData);        // Load secondary data after a short delay    const activityTimer = setTimeout(() => {      fetchActivityData().then(setActivityData);    }, 100);        // Load non-critical data last    const reportsTimer = setTimeout(() => {      fetchReportsData().then(setReportsData);    }, 500);        return () => {      clearTimeout(activityTimer);      clearTimeout(reportsTimer);    };  }, []);    return (    <div className="dashboard-content">      {/* Critical: Show immediately, with skeleton */}      <SummaryCards data={summaryData} />            {/* Important but secondary */}      {activityData ? (        <RecentActivity data={activityData} />      ) : (        <ActivitySkeleton />      )}            {/* Non-critical: Only show when data is ready */}      {reportsData && <DetailedReports data={reportsData} />}    </div>  );}```## Production Optimization### Build Optimization1. **Analyze Bundle Size**:   ```bash   pnpm build --analyze   ```2. **Size Limits**: Enforce size limits for bundles3. **Bundle Optimization**:   ```javascript   // next.config.js   module.exports = {     // ...     webpack: (config, { isServer }) => {       // Split chunks more aggressively       if (!isServer) {         config.optimization.splitChunks = {           chunks: 'all',           minSize: 20000,           maxSize: 90000,         };       }              return config;     },   };   ```### Environment ConfigurationSet up proper environment configuration for production:```typescript// Create a config object with environment-specific valuesexport const config = {  apiUrl: process.env.NEXT_PUBLIC_API_URL,  maxItemsPerPage: parseInt(process.env.NEXT_PUBLIC_MAX_ITEMS_PER_PAGE || '10', 10),  debug: process.env.NODE_ENV === 'development',  sentryDsn: process.env.NEXT_PUBLIC_SENTRY_DSN,};```## Performance ChecklistUse this checklist for regular performance audits:### Frontend- [ ] Use dynamic imports for large components- [ ] Implement virtualization for long lists/tables- [ ] Memoize expensive components and calculations- [ ] Optimize image loading with next/image- [ ] Minimize unnecessary re-renders- [ ] Add loading states and skeletons- [ ] Use pagination for large datasets- [ ] Implement proper error boundaries### Backend- [ ] Optimize database queries- [ ] Add appropriate indexes- [ ] Implement API response caching- [ ] Use pagination for list endpoints- [ ] Optimize relation fetching- [ ] Compress API responses- [ ] Batch related operations when possible### General- [ ] Set up performance monitoring- [ ] Analyze and split large bundles- [ ] Set cache headers appropriately- [ ] Enable compression- [ ] Use web vitals reporting- [ ] Implement load testing# Accessibility Guidelines# Accessibility Guidelines## OverviewThe GlobalRx application follows WCAG 2.1 AA standards to ensure that the platform is accessible to all users, including those with disabilities. This document outlines the accessibility standards and guidelines that should be followed throughout the project.## Core Accessibility Principles### 1. PerceivableInformation and user interface components must be presentable to users in ways they can perceive.### 2. OperableUser interface components and navigation must be operable.### 3. UnderstandableInformation and the operation of the user interface must be understandable.### 4. RobustContent must be robust enough to be interpreted reliably by a wide variety of user agents, including assistive technologies.## HTML Semantic Structure### Document StructureUse semantic HTML elements to properly structure content:```html<!-- Bad: Divs with no semantic meaning --><div class="header">  <div class="logo">GlobalRx</div>  <div class="nav">...</div></div><div class="main">  <div class="title">Welcome</div>  <div class="content">...</div></div><div class="footer">...</div><!-- Good: Semantic HTML --><header>  <h1>GlobalRx</h1>  <nav>...</nav></header><main>  <h2>Welcome</h2>  <section>...</section></main><footer>...</footer>```### HeadingsUse proper heading hierarchy to create a logical document outline:```tsx// Good: Proper heading hierarchyexport function PageStructure() {  return (    <div>      <h1>Main Page Title</h1>      <section>        <h2>Section Title</h2>        <article>          <h3>Article Title</h3>          <p>Content...</p>        </article>      </section>    </div>  );}```### ARIA LandmarksUse ARIA landmarks to identify regions of a page:```tsx// Explicitly define landmarks export function PageLayout() {  return (    <div>      <header role="banner">        <h1>GlobalRx</h1>      </header>      <nav role="navigation">        {/* Navigation items */}      </nav>      <main role="main">        {/* Main content */}      </main>      <aside role="complementary">        {/* Supplementary content */}      </aside>      <footer role="contentinfo">        {/* Footer content */}      </footer>    </div>  );}```## Keyboard Accessibility### Keyboard NavigationEnsure all interactive elements are keyboard accessible:```tsx// Bad: Not keyboard accessible<div   className="card clickable"   onClick={handleClick}>  Click me</div>// Good: Keyboard accessible<button   className="card clickable"  onClick={handleClick}>  Click me</button>```### Focus Management#### Focus IndicatorsEnsure focus indicators are visible:```css/* In globals.css */:focus {  outline: 2px solid #3b82f6;  outline-offset: 2px;}/* For custom focus styles that maintain visibility */.custom-button:focus-visible {  outline: 2px solid #3b82f6;  outline-offset: 2px;}```#### Focus Trapping in DialogsTrap focus within modal dialogs:```tsx// src/components/ui/modal-dialog.tsximport React, { useRef, useEffect, forwardRef, useImperativeHandle } from 'react';import { Button } from '@/components/ui/button';interface ModalDialogProps {  title: string;  children: React.ReactNode;  footer?: React.ReactNode;  maxWidth?: string;  onClose?: () => void;}export interface DialogRef {  showModal: () => void;  close: () => void;}export const ModalDialog = forwardRef<DialogRef, ModalDialogProps>(  ({ title, children, footer, maxWidth = "md", onClose }, ref) => {    const dialogRef = useRef<HTMLDialogElement>(null);    const firstFocusableRef = useRef<HTMLElement | null>(null);    const lastFocusableRef = useRef<HTMLElement | null>(null);    // Expose methods    useImperativeHandle(ref, () => ({      showModal: () => {        dialogRef.current?.showModal();        setupFocusTrap();      },      close: () => dialogRef.current?.close()    }));        // Setup focus trap for keyboard accessibility    const setupFocusTrap = () => {      setTimeout(() => {        if (!dialogRef.current) return;                // Get all focusable elements        const focusableElements = dialogRef.current.querySelectorAll<HTMLElement>(          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'        );        if (focusableElements.length) {          firstFocusableRef.current = focusableElements[0];          lastFocusableRef.current = focusableElements[focusableElements.length - 1];                    // Focus the first element          firstFocusableRef.current.focus();        }      }, 50);    };    // Handle keyboard navigation inside dialog    const handleKeyDown = (e: React.KeyboardEvent) => {      if (e.key === 'Tab') {        // If focusing on last element and pressing Tab, focus on first element        if (!e.shiftKey && document.activeElement === lastFocusableRef.current) {          e.preventDefault();          firstFocusableRef.current?.focus();        }         // If focusing on first element and pressing Shift+Tab, focus on last element        else if (e.shiftKey && document.activeElement === firstFocusableRef.current) {          e.preventDefault();          lastFocusableRef.current?.focus();        }      }    };    // Close handler    const handleClose = () => {      if (onClose) onClose();      dialogRef.current?.close();    };    // Determine max width    const widthClasses = {      sm: "max-w-sm",      md: "max-w-md",      lg: "max-w-lg",      xl: "max-w-xl",      "2xl": "max-w-2xl",      full: "max-w-full"    };    const maxWidthClass = widthClasses[maxWidth as keyof typeof widthClasses] || "max-w-md";    return (      <dialog         ref={dialogRef}         className={`p-0 rounded-lg shadow-lg backdrop:bg-black backdrop:bg-opacity-50 w-full ${maxWidthClass}`}        onKeyDown={handleKeyDown}        aria-labelledby="dialog-title"        aria-modal="true"      >        <div className="bg-white p-6">          <div className="flex justify-between items-center mb-4">            <h3 id="dialog-title" className="text-lg font-bold">{title}</h3>            <button               onClick={handleClose}              className="text-gray-500 hover:text-gray-700"              aria-label="Close dialog"            >              ?            </button>          </div>                    <div className="py-2">            {children}          </div>                    {footer && (            <div className="flex justify-end gap-2 mt-6">              {footer}            </div>          )}        </div>      </dialog>    );  });ModalDialog.displayName = 'ModalDialog';```### Skip LinksImplement skip links for keyboard users:```tsx// src/components/layout/skip-link.tsx'use client';import { useState } from 'react';export function SkipLink() {  const [focused, setFocused] = useState(false);    return (    <a      href="#main-content"      className={`        fixed top-2 left-2 p-2 bg-white border border-gray-300 rounded         shadow-md z-50 transform -translate-y-20 focus:translate-y-0         focus:outline-none focus:ring-2 focus:ring-blue-500        ${focused ? 'translate-y-0' : '-translate-y-20'}      `}      onFocus={() => setFocused(true)}      onBlur={() => setFocused(false)}    >      Skip to main content    </a>  );}// In the main layout<body>  <SkipLink />  <header>...</header>  <main id="main-content">...</main></body>```## Forms and Inputs### Form LabelingEnsure all form controls have associated labels:```tsx// Bad: No accessible label<input type="text" placeholder="Enter your name" />// Good: Accessible label<div>  <label htmlFor="name">Name</label>  <input id="name" type="text" placeholder="Enter your name" /></div>// Hidden label but still accessible<div>  <label htmlFor="search" className="sr-only">Search</label>  <input id="search" type="search" placeholder="Search" /></div>```### Form ValidationProvide accessible error messages for form validation:```tsximport { useState } from 'react';import { FormRow } from '@/components/ui/form';import { Input } from '@/components/ui/input';export function AccessibleForm() {  const [email, setEmail] = useState('');  const [emailError, setEmailError] = useState('');    const validateEmail = () => {    if (!email) {      setEmailError('Email is required');      return false;    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {      setEmailError('Please enter a valid email address');      return false;    }        setEmailError('');    return true;  };    return (    <form>      <FormRow        label="Email"        htmlFor="email"        required={true}        error={emailError}      >        <Input          id="email"          type="email"          value={email}          onChange={(e) => setEmail(e.target.value)}          onBlur={validateEmail}          aria-required="true"          aria-invalid={!!emailError}          aria-describedby={emailError ? "email-error" : undefined}        />                {emailError && (          <div id="email-error" className="text-red-500 text-sm mt-1">            {emailError}          </div>        )}      </FormRow>            {/* More form fields... */}    </form>  );}```## Color and Contrast### Contrast RequirementsEnsure text meets WCAG AA contrast requirements:- Normal text (less than 18pt): 4.5:1 minimum contrast ratio- Large text (18pt or larger): 3:1 minimum contrast ratio- UI components and graphics: 3:1 minimum contrast ratioExample color utility functions:```typescript// src/lib/color-utils.ts// Calculate contrast ratio between two colorsexport function getContrastRatio(foreground: string, background: string): number {  const getLuminance = (color: string): number => {    // Convert hex to RGB    const hex = color.startsWith('#') ? color.slice(1) : color;    const r = parseInt(hex.substr(0, 2), 16) / 255;    const g = parseInt(hex.substr(2, 2), 16) / 255;    const b = parseInt(hex.substr(4, 2), 16) / 255;        // Calculate relative luminance    const R = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);    const G = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);    const B = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);        return 0.2126 * R + 0.7152 * G + 0.0722 * B;  };    const luminance1 = getLuminance(foreground);  const luminance2 = getLuminance(background);    const lighter = Math.max(luminance1, luminance2);  const darker = Math.min(luminance1, luminance2);    return (lighter + 0.05) / (darker + 0.05);}// Check if a color combination passes WCAG AAexport function passesWCAGAA(foreground: string, background: string, isLargeText: boolean = false): boolean {  const contrast = getContrastRatio(foreground, background);  return isLargeText ? contrast >= 3 : contrast >= 4.5;}```### Color Not the Only Means of Conveying InformationNever use color alone to convey information:```tsx// Bad: Color alone to indicate status<div className={status === 'error' ? 'text-red-500' : 'text-green-500'}>  Status</div>// Good: Color with text and icon<div   className={`flex items-center ${status === 'error' ? 'text-red-500' : 'text-green-500'}`}  aria-label={status === 'error' ? 'Error status' : 'Success status'}>  {status === 'error' ? <ErrorIcon className="mr-1" /> : <SuccessIcon className="mr-1" />}  {status === 'error' ? 'Error' : 'Success'}</div>```## Images and Media### Alternative TextProvide alternative text for images:```tsx// Bad: Missing alt text<img src="/logo.png" />// Bad: Redundant alt text<img src="/logo.png" alt="Logo image" />// Good: Descriptive alt text<img src="/logo.png" alt="GlobalRx Company Logo" />// Decorative image<img src="/decorative-pattern.png" alt="" role="presentation" />```### Complex ImagesFor complex images, provide extended descriptions:```tsx<figure>  <img     src="/chart-quarterly-results.png"     alt="Bar chart of quarterly results"     aria-describedby="chart-description"  />  <figcaption id="chart-description">    The chart shows quarterly growth across four quarters. Q1: 15%, Q2: 22%,     Q3: 19%, and Q4: 28%, demonstrating an overall positive trend with the     strongest performance in Q4.  </figcaption></figure>```## ARIA Attributes### Dynamic Content UpdatesUse ARIA live regions for dynamic content:```tsx// For polite announcements (wait until current task finishes)<div aria-live="polite" aria-atomic="true">  {statusMessage}</div>// For assertive announcements (interrupt current task)<div aria-live="assertive" aria-atomic="true">  {errorMessage}</div>```Example notification component:```tsx// src/components/ui/notification.tsximport { useEffect, useState } from 'react';interface NotificationProps {  message: string;  type: 'info' | 'success' | 'error' | 'warning';  duration?: number;  isVisible: boolean;}export function Notification({   message,   type,   duration = 5000,   isVisible }: NotificationProps) {  const [isHidden, setIsHidden] = useState(!isVisible);    useEffect(() => {    if (isVisible) {      setIsHidden(false);            if (duration > 0) {        const timer = setTimeout(() => {          setIsHidden(true);        }, duration);                return () => clearTimeout(timer);      }    } else {      setIsHidden(true);    }  }, [isVisible, duration]);    // ARIA live role based on type  const ariaLive = type === 'error' ? 'assertive' : 'polite';    return (    <div       aria-live={ariaLive}      aria-atomic="true"      className={`        notification-container        ${isHidden ? 'hidden' : ''}        ${type === 'error' ? 'bg-red-100 border-red-500' : ''}        ${type === 'success' ? 'bg-green-100 border-green-500' : ''}        ${type === 'warning' ? 'bg-amber-100 border-amber-500' : ''}        ${type === 'info' ? 'bg-blue-100 border-blue-500' : ''}      `}    >      <div className="p-4">        {message}      </div>    </div>  );}```### ARIA RolesUse ARIA roles appropriately:```tsx// Tab interface example<div role="tablist">  <button     role="tab"     aria-selected={activeTab === 'tab1'}     aria-controls="panel1"    id="tab1"    onClick={() => setActiveTab('tab1')}  >    Tab 1  </button>  <button     role="tab"     aria-selected={activeTab === 'tab2'}     aria-controls="panel2"    id="tab2"    onClick={() => setActiveTab('tab2')}  >    Tab 2  </button></div><div   id="panel1"   role="tabpanel"   aria-labelledby="tab1"  hidden={activeTab !== 'tab1'}>  Panel 1 content</div><div   id="panel2"   role="tabpanel"   aria-labelledby="tab2"  hidden={activeTab !== 'tab2'}>  Panel 2 content</div>```## Tables### Accessible TablesCreate accessible data tables:```tsx<div className="overflow-x-auto">  <table     className="w-full border-collapse"     aria-label="Monthly Revenue by Region"  >    <caption className="sr-only">Monthly Revenue by Region</caption>    <thead>      <tr>        <th scope="col">Region</th>        <th scope="col">January</th>        <th scope="col">February</th>        <th scope="col">March</th>      </tr>    </thead>    <tbody>      <tr>        <th scope="row">North</th>        <td>$10,000</td>        <td>$12,000</td>        <td>$15,000</td>      </tr>      <tr>        <th scope="row">South</th>        <td>$8,000</td>        <td>$9,000</td>        <td>$10,000</td>      </tr>      <tr>        <th scope="row">East</th>        <td>$9,000</td>        <td>$10,000</td>        <td>$11,000</td>      </tr>    </tbody>    <tfoot>      <tr>        <th scope="row">Total</th>        <td>$27,000</td>        <td>$31,000</td>        <td>$36,000</td>      </tr>    </tfoot>  </table></div>```## Responsive Design and Accessibility### Mobile AccessibilityEnsure the application is accessible on mobile devices:1. **Touch Targets**: Ensure touch targets are at least 44x44 pixels2. **Viewport Settings**: Set proper viewport meta tag3. **Responsive Testing**: Test with screen readers on mobile devicesExample viewport settings:```html<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0" />```## Screen Reader Support### Hidden Text for Screen ReadersAdd context for screen readers when needed:```tsx// Visually hidden text for screen readers<span className="sr-only">Opens in a new window</span>// CSS for sr-only class.sr-only {  position: absolute;  width: 1px;  height: 1px;  padding: 0;  margin: -1px;  overflow: hidden;  clip: rect(0, 0, 0, 0);  white-space: nowrap;  border-width: 0;}```### Descriptive Button TextEnsure button labels are descriptive:```tsx// Bad: Generic button text<button onClick={() => deleteUser(user.id)}>Delete</button>// Good: Specific button text<button onClick={() => deleteUser(user.id)}>  Delete {user.name}</button>// Or use aria-label if visual space is limited<button   onClick={() => deleteUser(user.id)}  aria-label={`Delete ${user.name}`}>  Delete</button>```## Testing Accessibility### Automated TestingUse automated testing tools to catch common accessibility issues:1. **ESLint with jsx-a11y**: Enforce accessibility best practices during development2. **Lighthouse**: Run Lighthouse audits regularly to check accessibility scores3. **Axe**: Integrate axe-core for automated accessibility testingExample ESLint config:```javascript// .eslintrc.jsmodule.exports = {  extends: [    // ... other extends    'plugin:jsx-a11y/recommended'  ],  plugins: [    // ... other plugins    'jsx-a11y'  ],  rules: {    // ... other rules    'jsx-a11y/aria-props': 'error',    'jsx-a11y/aria-proptypes': 'error',    'jsx-a11y/aria-unsupported-elements': 'error',    'jsx-a11y/role-has-required-aria-props': 'error',    'jsx-a11y/role-supports-aria-props': 'error'  }};```### Manual TestingManual testing is essential for thorough accessibility evaluation:1. **Keyboard Navigation**: Test navigation using only the keyboard2. **Screen Reader Testing**: Test with screen readers like NVDA, JAWS, or VoiceOver3. **Zoom Testing**: Test the application at different zoom levels (up to 200%)4. **Contrast Checking**: Use tools to verify color contrast ratios5. **Reduced Motion**: Test with reduced motion preferences enabled### Accessibility ChecklistUse this checklist when developing new features:- [ ] All interactive elements are keyboard accessible- [ ] All form fields have proper labels- [ ] All images have appropriate alt text- [ ] Color is not the only means of conveying information- [ ] Text has sufficient color contrast- [ ] ARIA attributes are used correctly- [ ] Page has a logical heading structure- [ ] Dynamic content changes are announced to screen readers- [ ] Custom components match their ARIA roles- [ ] The feature works with screen readers# Testing Standards# Testing Standards## Testing ApproachThe GlobalRx platform employs a comprehensive testing strategy to ensure code quality, catch bugs early, and maintain the reliability of the application. Our testing approach is based on the testing pyramid, which consists of unit tests, integration tests, and end-to-end tests.### Testing Pyramid1. **Unit Tests**: Form the base of the testing pyramid with the most tests.   - Test individual functions, hooks, and components in isolation   - Run quickly and provide fast feedback   - Should cover all business logic and utility functions2. **Integration Tests**: The middle layer of the pyramid.   - Test how components work together   - Test API routes and database interactions   - Focus on ensuring different parts of the application work together correctly3. **End-to-End Tests**: The top of the pyramid with the fewest tests.   - Test complete user flows from start to finish   - Run in a browser environment similar to production   - Cover critical paths through the application## Test TechnologiesThe GlobalRx platform uses the following testing technologies:1. **Jest**: For unit and integration testing2. **React Testing Library**: For component testing3. **MSW (Mock Service Worker)**: For mocking API requests4. **Cypress**: For end-to-end testing5. **Storybook**: For component development and visual testing## Unit Testing### Setting Up JestJest is configured in the project to work with Next.js and TypeScript:```javascript// jest.config.jsconst nextJest = require('next/jest');const createJestConfig = nextJest({  // Provide the path to your Next.js app to load next.config.js and .env files  dir: './',});// Add custom Jest configurationconst customJestConfig = {  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],  moduleNameMapper: {    // Handle module aliases (if you're using them)    '^@/components/(.*)$': '<rootDir>/src/components/$1',    '^@/lib/(.*)$': '<rootDir>/src/lib/$1',    '^@/hooks/(.*)$': '<rootDir>/src/hooks/$1',    '^@/contexts/(.*)$': '<rootDir>/src/contexts/$1',  },  testEnvironment: 'jest-environment-jsdom',  testPathIgnorePatterns: ['<rootDir>/cypress/'],};// createJestConfig is exported from next/jest to do some customizationmodule.exports = createJestConfig(customJestConfig);```Setup file for Jest:```javascript// jest.setup.jsimport '@testing-library/jest-dom';import 'whatwg-fetch';import { server } from './src/mocks/server';// Establish API mocking before all testsbeforeAll(() => server.listen());// Reset any request handlers between testsafterEach(() => server.resetHandlers());// Clean up after all tests are doneafterAll(() => server.close());```### Testing Utility FunctionsUtility functions should have thorough unit tests:```typescript// src/lib/utils.tsexport function formatCurrency(value: number, currency = 'USD'): string {  return new Intl.NumberFormat('en-US', {    style: 'currency',    currency,  }).format(value);}export function calculateTotal(items: { price: number; quantity: number }[]): number {  return items.reduce((total, item) => total + item.price * item.quantity, 0);}```Unit tests for these utilities:```typescript// src/lib/__tests__/utils.test.tsimport { formatCurrency, calculateTotal } from '../utils';describe('formatCurrency', () => {  it('formats USD currency correctly', () => {    expect(formatCurrency(1000)).toBe('$1,000.00');    expect(formatCurrency(1234.56)).toBe('$1,234.56');    expect(formatCurrency(0)).toBe('$0.00');  });  it('formats other currencies correctly', () => {    expect(formatCurrency(1000, 'EUR')).toBe('Û1,000.00');    expect(formatCurrency(1000, 'GBP')).toBe('£1,000.00');  });});describe('calculateTotal', () => {  it('calculates total correctly for multiple items', () => {    const items = [      { price: 10, quantity: 2 },      { price: 15, quantity: 3 },      { price: 5, quantity: 1 },    ];    expect(calculateTotal(items)).toBe(65); // (10*2) + (15*3) + (5*1) = 65  });  it('returns 0 for empty items array', () => {    expect(calculateTotal([])).toBe(0);  });});```### Testing React HooksCustom hooks should be tested using the `@testing-library/react-hooks` package:```typescript// src/hooks/useCounter.tsimport { useState, useCallback } from 'react';export function useCounter(initialValue = 0) {  const [count, setCount] = useState(initialValue);  const increment = useCallback(() => setCount(prev => prev + 1), []);  const decrement = useCallback(() => setCount(prev => prev - 1), []);  const reset = useCallback(() => setCount(initialValue), [initialValue]);  return { count, increment, decrement, reset };}```Testing the hook:```typescript// src/hooks/__tests__/useCounter.test.tsimport { renderHook, act } from '@testing-library/react-hooks';import { useCounter } from '../useCounter';describe('useCounter', () => {  it('should initialize with default value', () => {    const { result } = renderHook(() => useCounter());    expect(result.current.count).toBe(0);  });  it('should initialize with provided value', () => {    const { result } = renderHook(() => useCounter(10));    expect(result.current.count).toBe(10);  });  it('should increment counter', () => {    const { result } = renderHook(() => useCounter());    act(() => {      result.current.increment();    });    expect(result.current.count).toBe(1);  });  it('should decrement counter', () => {    const { result } = renderHook(() => useCounter(5));    act(() => {      result.current.decrement();    });    expect(result.current.count).toBe(4);  });  it('should reset counter to initial value', () => {    const { result } = renderHook(() => useCounter(3));    act(() => {      result.current.increment();      result.current.increment();      result.current.reset();    });    expect(result.current.count).toBe(3);  });});```## Component Testing### Testing Simple ComponentsUse React Testing Library to test simple components:```tsx// src/components/ui/button.tsximport React from 'react';interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {  variant?: 'default' | 'outline' | 'destructive';  size?: 'sm' | 'md' | 'lg';  children: React.ReactNode;}export function Button({   variant = 'default',   size = 'md',   children,   ...props }: ButtonProps) {  const baseClasses = 'font-medium rounded focus:outline-none focus:ring-2 focus:ring-blue-500';    const variantClasses = {    default: 'bg-blue-500 text-white hover:bg-blue-600',    outline: 'bg-white text-blue-500 border border-blue-500 hover:bg-blue-50',    destructive: 'bg-red-500 text-white hover:bg-red-600',  };    const sizeClasses = {    sm: 'px-2 py-1 text-sm',    md: 'px-4 py-2',    lg: 'px-6 py-3 text-lg',  };    const className = `${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]} ${props.className || ''}`;    return (    <button className={className} {...props}>      {children}    </button>  );}```Testing the button component:```tsx// src/components/ui/__tests__/button.test.tsximport { render, screen } from '@testing-library/react';import userEvent from '@testing-library/user-event';import { Button } from '../button';describe('Button', () => {  it('renders correctly with default props', () => {    render(<Button>Click me</Button>);    const button = screen.getByRole('button', { name: /click me/i });    expect(button).toBeInTheDocument();    expect(button).toHaveClass('bg-blue-500');  });  it('renders correctly with outline variant', () => {    render(<Button variant="outline">Outline</Button>);    const button = screen.getByRole('button', { name: /outline/i });    expect(button).toHaveClass('bg-white');    expect(button).toHaveClass('border-blue-500');  });  it('renders correctly with destructive variant', () => {    render(<Button variant="destructive">Delete</Button>);    const button = screen.getByRole('button', { name: /delete/i });    expect(button).toHaveClass('bg-red-500');  });  it('renders with different sizes', () => {    const { rerender } = render(<Button size="sm">Small</Button>);    expect(screen.getByRole('button', { name: /small/i })).toHaveClass('px-2 py-1');    rerender(<Button size="lg">Large</Button>);    expect(screen.getByRole('button', { name: /large/i })).toHaveClass('px-6 py-3');  });  it('calls onClick handler when clicked', async () => {    const handleClick = jest.fn();    render(<Button onClick={handleClick}>Click me</Button>);        await userEvent.click(screen.getByRole('button', { name: /click me/i }));    expect(handleClick).toHaveBeenCalledTimes(1);  });  it('applies additional className when provided', () => {    render(<Button className="custom-class">Custom</Button>);    expect(screen.getByRole('button', { name: /custom/i })).toHaveClass('custom-class');  });  it('forwards additional props to the button element', () => {    render(<Button data-testid="test-button" disabled>Disabled</Button>);    const button = screen.getByTestId('test-button');    expect(button).toBeDisabled();  });});```### Testing Complex ComponentsFor more complex components with dependencies, use mocks:```tsx// src/components/modules/user-admin/user-list.tsx'use client';import { useState, useEffect } from 'react';import { useAuth } from '@/components/auth/auth-interceptor';import { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from '@/components/ui/table';import { Button } from '@/components/ui/button';import { ActionDropdown } from '@/components/ui/action-dropdown';interface User {  id: string;  email: string;  firstName?: string;  lastName?: string;  disabled: boolean;}export function UserList() {  const [users, setUsers] = useState<User[]>([]);  const [isLoading, setIsLoading] = useState(true);  const [error, setError] = useState<string | null>(null);  const { fetchWithAuth } = useAuth();  const fetchUsers = async () => {    try {      setIsLoading(true);      setError(null);            const response = await fetchWithAuth('/api/users');            if (!response.ok) {        throw new Error(`Failed to fetch users: ${response.status}`);      }            const data = await response.json();      setUsers(data);    } catch (err) {      console.error('Error fetching users:', err);      setError(err instanceof Error ? err.message : 'An error occurred');    } finally {      setIsLoading(false);    }  };  useEffect(() => {    fetchUsers();  }, []);  const handleToggleStatus = async (userId: string) => {    try {      const response = await fetchWithAuth(`/api/users/${userId}/toggle-status`, {        method: 'PATCH',      });            if (!response.ok) {        throw new Error('Failed to update user status');      }            // Refresh the user list      fetchUsers();    } catch (err) {      console.error('Error toggling user status:', err);      setError(err instanceof Error ? err.message : 'An error occurred');    }  };  if (isLoading) {    return <div>Loading users...</div>;  }  if (error) {    return (      <div className="text-red-500">        Error: {error}        <Button onClick={fetchUsers} className="ml-2">Retry</Button>      </div>    );  }  return (    <div>      <Table>        <TableHeader>          <TableRow>            <TableHead>Email</TableHead>            <TableHead>Name</TableHead>            <TableHead>Status</TableHead>            <TableHead className="text-center">Actions</TableHead>          </TableRow>        </TableHeader>        <TableBody>          {users.map(user => (            <TableRow key={user.id}>              <TableCell>{user.email}</TableCell>              <TableCell>                {user.firstName || user.lastName                  ? `${user.firstName || ''} ${user.lastName || ''}`                  : 'N/A'}              </TableCell>              <TableCell>{user.disabled ? 'Disabled' : 'Active'}</TableCell>              <TableCell className="text-center">                <ActionDropdown                  options={[                    {                      label: 'Edit',                      onClick: () => { /* Handle edit */ },                      color: 'rgb(37, 99, 235)',                    },                    {                      label: user.disabled ? 'Enable' : 'Disable',                      onClick: () => handleToggleStatus(user.id),                      color: user.disabled ? 'rgb(37, 99, 235)' : 'rgb(220, 38, 38)',                    },                  ]}                />              </TableCell>            </TableRow>          ))}        </TableBody>      </Table>    </div>  );}```Testing this component:```tsx// src/components/modules/user-admin/__tests__/user-list.test.tsximport { render, screen, waitFor } from '@testing-library/react';import userEvent from '@testing-library/user-event';import { UserList } from '../user-list';import { useAuth } from '@/components/auth/auth-interceptor';// Mock the auth hookjest.mock('@/components/auth/auth-interceptor', () => ({  useAuth: jest.fn(),}));// Mock the ActionDropdown componentjest.mock('@/components/ui/action-dropdown', () => ({  ActionDropdown: ({ options }) => (    <div data-testid="action-dropdown">      {options.map((option, index) => (        <button           key={index}          onClick={option.onClick}          data-testid={`dropdown-option-${option.label}`}        >          {option.label}        </button>      ))}    </div>  ),}));describe('UserList', () => {  const mockUsers = [    {      id: '1',      email: 'user1@example.com',      firstName: 'John',      lastName: 'Doe',      disabled: false,    },    {      id: '2',      email: 'user2@example.com',      firstName: 'Jane',      lastName: 'Smith',      disabled: true,    },  ];  // Setup mock for fetchWithAuth  const mockFetchWithAuth = jest.fn();    beforeEach(() => {    jest.clearAllMocks();        // Configure the mock implementation for useAuth    (useAuth as jest.Mock).mockReturnValue({      fetchWithAuth: mockFetchWithAuth,    });        // Mock successful fetch response for users    mockFetchWithAuth.mockResolvedValueOnce({      ok: true,      json: async () => mockUsers,    });  });  it('renders loading state initially', () => {    render(<UserList />);    expect(screen.getByText('Loading users...')).toBeInTheDocument();  });  it('renders users after loading', async () => {    render(<UserList />);        // Wait for the loading state to be replaced    await waitFor(() => expect(screen.queryByText('Loading users...')).not.toBeInTheDocument());        // Check if both users are displayed    expect(screen.getByText('user1@example.com')).toBeInTheDocument();    expect(screen.getByText('John Doe')).toBeInTheDocument();    expect(screen.getByText('user2@example.com')).toBeInTheDocument();    expect(screen.getByText('Jane Smith')).toBeInTheDocument();        // Check status    expect(screen.getByText('Active')).toBeInTheDocument();    expect(screen.getByText('Disabled')).toBeInTheDocument();  });  it('handles error when fetching users fails', async () => {    // Override the mock to simulate an error    mockFetchWithAuth.mockReset();    mockFetchWithAuth.mockResolvedValueOnce({      ok: false,      status: 500,    });        render(<UserList />);        // Wait for the error message to appear    await waitFor(() => expect(screen.getByText(/Error:/)).toBeInTheDocument());    expect(screen.getByText(/Failed to fetch users: 500/)).toBeInTheDocument();        // Check if retry button is present    expect(screen.getByText('Retry')).toBeInTheDocument();  });  it('handles toggling user status', async () => {    // Setup additional mock for toggle status API call    mockFetchWithAuth.mockResolvedValueOnce({      ok: true,      json: async () => mockUsers,    });        mockFetchWithAuth.mockResolvedValueOnce({      ok: true,      json: async () => ({}),    });        // Setup another mock for the re-fetch after toggle    mockFetchWithAuth.mockResolvedValueOnce({      ok: true,      json: async () => [        { ...mockUsers[0], disabled: true },        mockUsers[1],      ],    });        render(<UserList />);        // Wait for users to load    await waitFor(() => expect(screen.queryByText('Loading users...')).not.toBeInTheDocument());        // Find and click the disable button for the first user    const disableButton = screen.getByTestId('dropdown-option-Disable');    await userEvent.click(disableButton);        // Verify API calls    expect(mockFetchWithAuth).toHaveBeenCalledTimes(2); // Initial fetch + toggle    expect(mockFetchWithAuth).toHaveBeenNthCalledWith(2, '/api/users/1/toggle-status', {      method: 'PATCH',    });        // Wait for the re-fetch to happen    await waitFor(() => expect(mockFetchWithAuth).toHaveBeenCalledTimes(3));  });});```## Integration Testing### Testing API RoutesTest API routes using Jest and Next.js testing utilities:```typescript// src/app/api/users/__tests__/route.test.tsimport { NextRequest } from 'next/server';import { GET } from '../route';import { getServerSession } from 'next-auth';import { prisma } from '@/lib/prisma';// Mock dependenciesjest.mock('next-auth', () => ({  getServerSession: jest.fn(),}));jest.mock('@/lib/prisma', () => ({  prisma: {    user: {      findMany: jest.fn(),    },  },}));describe('GET /api/users', () => {  beforeEach(() => {    jest.clearAllMocks();  });    it('returns 401 when not authenticated', async () => {    // Set up the mock to return null for unauthenticated session    (getServerSession as jest.Mock).mockResolvedValueOnce(null);        // Create a mock request    const request = new NextRequest('http://localhost:3000/api/users');        // Call the API route handler    const response = await GET(request);        // Check the response    expect(response.status).toBe(401);    const data = await response.json();    expect(data).toEqual({ error: 'Unauthorized' });  });    it('returns 403 when user does not have necessary permissions', async () => {    // Set up the mock to return a session without correct permissions    (getServerSession as jest.Mock).mockResolvedValueOnce({      user: {        id: 'user-123',        permissions: {          users: {            view: false,          },        },      },    });        // Create a mock request    const request = new NextRequest('http://localhost:3000/api/users');        // Call the API route handler    const response = await GET(request);        // Check the response    expect(response.status).toBe(403);    const data = await response.json();    expect(data).toEqual({ error: 'Forbidden' });  });    it('returns users when authenticated and authorized', async () => {    // Set up the mock to return a session with correct permissions    (getServerSession as jest.Mock).mockResolvedValueOnce({      user: {        id: 'user-123',        permissions: {          users: {            view: true,          },        },      },    });        // Mock the database response    const mockUsers = [      { id: '1', email: 'user1@example.com' },      { id: '2', email: 'user2@example.com' },    ];    (prisma.user.findMany as jest.Mock).mockResolvedValueOnce(mockUsers);        // Create a mock request    const request = new NextRequest('http://localhost:3000/api/users');        // Call the API route handler    const response = await GET(request);        // Check the response    expect(response.status).toBe(200);    const data = await response.json();    expect(data).toEqual(mockUsers);        // Verify the prisma query    expect(prisma.user.findMany).toHaveBeenCalledTimes(1);    expect(prisma.user.findMany).toHaveBeenCalledWith({      where: { disabled: false },      select: {        id: true,        email: true,        firstName: true,        lastName: true,        disabled: true,        createdAt: true,      },    });  });});```### Testing Database InteractionsTest database operations using an in-memory database or test database:```typescript// src/lib/__tests__/user-service.test.tsimport { PrismaClient } from '@prisma/client';import { v4 as uuidv4 } from 'uuid';import {   createUser,   getUserById,   updateUser,   toggleUserStatus } from '../user-service';// Use a separate test database URL for testingconst prisma = new PrismaClient({  datasources: {    db: {      url: process.env.TEST_DATABASE_URL,    },  },});// Generate a unique test ID to avoid collisionsconst testId = uuidv4();describe('User Service', () => {  // Test user data  const userData = {    email: `test-${testId}@example.com`,    firstName: 'Test',    lastName: 'User',    password: 'hashed-password', // In a real test, you'd use bcrypt    permissions: { users: { view: true } },  };    let createdUserId: string;    // Clean up after tests  afterAll(async () => {    // Delete test users    await prisma.user.deleteMany({      where: {        email: {          contains: testId,        },      },    });        await prisma.$disconnect();  });    it('creates a new user', async () => {    const user = await createUser(userData);        expect(user).toHaveProperty('id');    expect(user.email).toBe(userData.email);    expect(user.firstName).toBe(userData.firstName);    expect(user.lastName).toBe(userData.lastName);    expect(user.disabled).toBe(false);        // Save the ID for later tests    createdUserId = user.id;  });    it('gets a user by ID', async () => {    const user = await getUserById(createdUserId);        expect(user).not.toBeNull();    expect(user?.id).toBe(createdUserId);    expect(user?.email).toBe(userData.email);  });    it('updates a user', async () => {    const updatedData = {      firstName: 'Updated',      lastName: 'Name',    };        const updatedUser = await updateUser(createdUserId, updatedData);        expect(updatedUser.firstName).toBe(updatedData.firstName);    expect(updatedUser.lastName).toBe(updatedData.lastName);    expect(updatedUser.email).toBe(userData.email); // Email should remain unchanged  });    it('toggles user status', async () => {    // Disable the user    let updatedUser = await toggleUserStatus(createdUserId);    expect(updatedUser.disabled).toBe(true);        // Enable the user    updatedUser = await toggleUserStatus(createdUserId);    expect(updatedUser.disabled).toBe(false);  });});```## End-to-End Testing### Setting Up CypressConfigure Cypress for end-to-end testing:```javascript// cypress.config.jsconst { defineConfig } = require('cypress');module.exports = defineConfig({  e2e: {    baseUrl: 'http://localhost:3000',    setupNodeEvents(on, config) {      // implement node event listeners here    },  },    component: {    devServer: {      framework: 'next',      bundler: 'webpack',    },  },    viewportWidth: 1280,  viewportHeight: 720,});```### Writing Cypress TestsExample of a basic Cypress test:```javascript// cypress/e2e/login.cy.jsdescribe('Login Page', () => {  beforeEach(() => {    // Visit the login page before each test    cy.visit('/login');  });    it('displays the login form', () => {    cy.get('form').should('be.visible');    cy.get('input[type="email"]').should('be.visible');    cy.get('input[type="password"]').should('be.visible');    cy.get('button[type="submit"]').should('be.visible');  });    it('shows error for invalid credentials', () => {    cy.get('input[type="email"]').type('invalid@example.com');    cy.get('input[type="password"]').type('wrongpassword');    cy.get('button[type="submit"]').click();        // Wait for the error message to appear    cy.get('.error-message').should('be.visible');    cy.get('.error-message').should('contain', 'Invalid email or password');  });    it('navigates to dashboard after successful login', () => {    // Use test credentials (these should be set up in your test environment)    cy.get('input[type="email"]').type('test@example.com');    cy.get('input[type="password"]').type('testpassword');    cy.get('button[type="submit"]').click();        // Verify redirection to dashboard    cy.url().should('include', '/dashboard');    cy.get('h1').should('contain', 'Dashboard');  });});```### Testing Critical User FlowsExample of testing a complete user flow:```javascript// cypress/e2e/user-management.cy.jsdescribe('User Management', () => {  beforeEach(() => {    // Log in as an admin user    cy.login('admin@example.com', 'adminpassword');        // Navigate to the user admin page    cy.visit('/admin/users');  });    it('allows creating a new user', () => {    // Generate a unique email to avoid conflicts    const uniqueEmail = `test-${Date.now()}@example.com`;        // Click the "Add User" button    cy.contains('button', 'Add User').click();        // Fill out the user form    cy.get('input[name="email"]').type(uniqueEmail);    cy.get('input[name="firstName"]').type('Test');    cy.get('input[name="lastName"]').type('User');    cy.get('input[name="password"]').type('TestPassword123!');    cy.get('input[name="confirmPassword"]').type('TestPassword123!');        // Select permissions    cy.get('input[name="permissions.users.view"]').check();        // Submit the form    cy.contains('button', 'Save').click();        // Verify success message    cy.contains('User created successfully').should('be.visible');        // Verify the new user appears in the table    cy.contains(uniqueEmail).should('be.visible');  });    it('allows editing an existing user', () => {    // Find a user in the table and click edit    cy.contains('tr', 'user@example.com')      .find('[data-testid="dropdown-option-Edit"]')      .click();        // Update user information    cy.get('input[name="firstName"]').clear().type('Updated');    cy.get('input[name="lastName"]').clear().type('Name');        // Submit the form    cy.contains('button', 'Save').click();        // Verify success message    cy.contains('User updated successfully').should('be.visible');        // Verify the updated information appears in the table    cy.contains('Updated Name').should('be.visible');  });    it('allows disabling and enabling a user', () => {    // Find a user in the table    const userRow = cy.contains('tr', 'user@example.com');        // Click disable    userRow.find('[data-testid="dropdown-option-Disable"]').click();        // Confirm in the dialog    cy.contains('button', 'Disable').click();        // Verify the user is now disabled    userRow.should('contain', 'Disabled');        // Click enable    userRow.find('[data-testid="dropdown-option-Enable"]').click();        // Confirm in the dialog    cy.contains('button', 'Enable').click();        // Verify the user is now active    userRow.should('contain', 'Active');  });});```## Testing Best Practices### Test CoverageAim for high test coverage across the application:1. **Unit Tests**: At least 80% coverage for utility functions and business logic2. **Component Tests**: Test all reusable UI components3. **Integration Tests**: Cover all API routes and database operations4. **End-to-End Tests**: Test all critical user flows### Testing UtilitiesCreate useful testing utilities to simplify common testing tasks:```typescript// src/test/utils.tsximport React, { ReactElement } from 'react';import { render, RenderOptions } from '@testing-library/react';import { TranslationProvider } from '@/contexts/TranslationContext';// Create a custom render function that includes providersfunction customRender(  ui: ReactElement,  options?: Omit<RenderOptions, 'wrapper'>) {  return render(ui, {    wrapper: ({ children }) => (      <TranslationProvider>        {children}      </TranslationProvider>    ),    ...options,  });}// Re-export everything from testing-libraryexport * from '@testing-library/react';// Override render methodexport { customRender as render };```### Test Data GenerationCreate utilities for generating test data:```typescript// src/test/data-generators.tsimport { v4 as uuidv4 } from 'uuid';export function generateUser(overrides = {}) {  const id = uuidv4();    return {    id,    email: `user-${id}@example.com`,    firstName: 'Test',    lastName: 'User',    disabled: false,    permissions: {      users: { view: true, create: false, edit: false },      countries: { view: true, manage: false },      services: { view: true, manage: false },      dsx: { view: true, manage: false },      customers: { view: true, create: false, edit: false, all: false },    },    createdAt: new Date().toISOString(),    updatedAt: new Date().toISOString(),    ...overrides,  };}export function generateLocation(overrides = {}) {  const id = uuidv4();    return {    id,    name: `Country ${id.substring(0, 4)}`,    code_2: `C${id.substring(0, 2)}`,    code_3: `COU${id.substring(0, 1)}`,    numeric: `${Math.floor(Math.random() * 900) + 100}`,    subregion1: null,    subregion2: null,    subregion3: null,    disabled: false,    ...overrides,  };}export function generateService(overrides = {}) {  const id = uuidv4();    return {    id,    name: `Service ${id.substring(0, 4)}`,    category: 'Testing',    description: 'A test service description',    functionalityType: 'verification',    disabled: false,    usage: 0,    ...overrides,  };}```### Mocking ServicesCreate mock implementations for external services:```typescript// src/mocks/handlers.jsimport { rest } from 'msw';export const handlers = [  // Mock authentication API  rest.post('/api/auth/signin', (req, res, ctx) => {    const { email, password } = req.body;        if (email === 'test@example.com' && password === 'password') {      return res(        ctx.status(200),        ctx.json({          user: {            id: 'user-123',            email: 'test@example.com',            name: 'Test User',          },          token: 'mock-jwt-token',        })      );    }        return res(      ctx.status(401),      ctx.json({ error: 'Invalid credentials' })    );  }),    // Mock users API  rest.get('/api/users', (req, res, ctx) => {    return res(      ctx.status(200),      ctx.json([        {          id: 'user-1',          email: 'user1@example.com',          firstName: 'User',          lastName: 'One',          disabled: false,        },        {          id: 'user-2',          email: 'user2@example.com',          firstName: 'User',          lastName: 'Two',          disabled: true,        },      ])    );  }),    // More mock API handlers...];```### Continuous IntegrationSet up continuous integration to run tests automatically:```yaml# .github/workflows/test.ymlname: Run Testson:  push:    branches: [main, develop]  pull_request:    branches: [main, develop]jobs:  test:    runs-on: ubuntu-latest        steps:      - uses: actions/checkout@v3            - name: Setup Node.js        uses: actions/setup-node@v3        with:          node-version: '18'          cache: 'pnpm'            - name: Install dependencies        run: pnpm install            - name: Lint        run: pnpm lint            - name: Type check        run: pnpm type-check            - name: Unit and integration tests        run: pnpm test            - name: Build        run: pnpm build            - name: Start server for E2E tests        run: pnpm start & npx wait-on http://localhost:3000            - name: E2E tests        run: pnpm cypress:run```## Test DocumentationDocument test strategies and approaches:1. **Test Plans**: Create test plans for critical features2. **Test Cases**: Document manual test cases for QA3. **Testing Standards**: Keep this documentation updated with current testing practices### Component Test Example Table| Component | Test Coverage | Key Scenarios ||-----------|--------------|--------------|| Button | 100% | Renders with different variants, sizes, and states || Form Components | 95% | Validation, error states, submission || UserList | 90% | Loading, error states, data display, user actions || ActionDropdown | 100% | Opens/closes, displays options, handles actions |### API Test Example Table| Endpoint | Test Coverage | Key Scenarios ||----------|--------------|--------------|| GET /api/users | 100% | Auth checks, permission checks, data retrieval || POST /api/users | 100% | Validation, creation, error handling || PATCH /api/users/:id/toggle-status | 90% | Status toggling, auth checks || GET /api/locations | 90% | Filtering, sorting, pagination |# API Standards# API Standards## API Design PrinciplesThe GlobalRx platform follows a set of consistent API design principles to ensure clarity, maintainability, and developer experience. These principles guide both internal API development and integration with external systems.### Core Principles1. **RESTful Design**: Follow REST principles for resource-oriented APIs2. **Consistency**: Maintain consistent patterns across all endpoints3. **Validation**: Validate all inputs and return clear error messages4. **Security**: Implement proper authentication and authorization5. **Performance**: Optimize for high performance and low latency6. **Documentation**: Document all endpoints comprehensively## API Structure### Base URL StructureAll internal API endpoints follow this URL structure:```/api/[resource]                    # Collection endpoints/api/[resource]/[id]               # Instance endpoints/api/[resource]/[id]/[action]      # Action endpoints```Examples:- `/api/users` - List or create users- `/api/users/123` - Get, update, or delete a specific user- `/api/users/123/toggle-status` - Perform a specific action on a user### HTTP MethodsUse standard HTTP methods for CRUD operations:| Method | Purpose | Example ||--------|---------|---------|| GET | Read resources | `GET /api/users` - List users || POST | Create resources | `POST /api/users` - Create a new user || PUT | Replace resources | `PUT /api/users/123` - Update all fields of a user || PATCH | Partial updates | `PATCH /api/users/123` - Update specific fields || DELETE | Remove resources | `DELETE /api/users/123` - Delete a user |### Status CodesUse appropriate HTTP status codes:| Code | Meaning | Example Use Case ||------|---------|------------------|| 200 | OK | Successful GET, PUT, PATCH, or DELETE || 201 | Created | Successful resource creation with POST || 204 | No Content | Successful operation with no response body || 400 | Bad Request | Invalid input, validation errors || 401 | Unauthorized | Missing or invalid authentication || 403 | Forbidden | Authentication succeeded but insufficient permissions || 404 | Not Found | Resource not found || 409 | Conflict | Resource already exists or conflict with current state || 422 | Unprocessable Entity | Request understood but cannot be processed || 500 | Internal Server Error | Server-side error |## Request Format### Query ParametersUse consistent query parameter naming and patterns:```/api/users?page=1&pageSize=10       # Pagination/api/users?sort=lastName            # Sorting (ascending)/api/users?sort=-lastName           # Sorting (descending)/api/users?search=john              # Searching/api/users?filter=disabled:true     # Filtering```Standard query parameters:| Parameter | Purpose | Format | Example ||-----------|---------|--------|---------|| page | Page number for pagination | Integer ³ 1 | `page=2` || pageSize | Items per page | Integer | `pageSize=25` || sort | Field to sort by | Field name with optional `-` prefix | `sort=-createdAt` || search | Search term | String | `search=john` || filter | Field-specific filtering | `field:value` | `filter=status:active` || include | Related resources to include | Comma-separated list | `include=permissions,roles` || fields | Fields to return | Comma-separated list | `fields=id,name,email` |### Request BodyUse consistent JSON structure for request bodies:```json// POST /api/users{  "email": "user@example.com",  "firstName": "John",  "lastName": "Doe",  "permissions": {    "users": {      "view": true,      "create": false    }  }}```Validation rules:- Required fields should always be present- Use appropriate data types- Validate format for emails, dates, etc.- Trim string inputs- Sanitize inputs to prevent XSS and SQL injection## Response Format### Success ResponsesFor standard GET requests (list):```json// GET /api/users{  "data": [    {      "id": "123",      "email": "user1@example.com",      "firstName": "John",      "lastName": "Doe",      "disabled": false    },    {      "id": "456",      "email": "user2@example.com",      "firstName": "Jane",      "lastName": "Smith",      "disabled": true    }  ],  "meta": {    "total": 50,    "page": 1,    "pageSize": 10,    "totalPages": 5  }}```For single resource GET, PUT, PATCH:```json// GET /api/users/123{  "id": "123",  "email": "user1@example.com",  "firstName": "John",  "lastName": "Doe",  "permissions": {    "users": {      "view": true,      "create": false,      "edit": false    },    "countries": {      "view": true,      "manage": false    }  },  "disabled": false,  "createdAt": "2023-01-15T12:00:00Z",  "updatedAt": "2023-01-20T14:30:00Z"}```For POST (creation):```json// POST /api/users{  "id": "789",  "email": "newuser@example.com",  "firstName": "New",  "lastName": "User",  "permissions": {    "users": {      "view": true,      "create": false,      "edit": false    }  },  "disabled": false,  "createdAt": "2023-03-01T09:15:00Z",  "updatedAt": "2023-03-01T09:15:00Z"}```### Error ResponsesStandardize error responses:```json// 400 Bad Request{  "error": "Validation failed",  "code": "VALIDATION_ERROR",  "details": {    "email": {      "message": "Email address is invalid",      "path": ["email"]    },    "firstName": {      "message": "First name is required",      "path": ["firstName"]    }  }}``````json// 404 Not Found{  "error": "User with ID 123 not found",  "code": "NOT_FOUND"}``````json// 403 Forbidden{  "error": "Insufficient permissions to access this resource",  "code": "FORBIDDEN"}```### HeadersUse appropriate response headers:```Content-Type: application/json; charset=utf-8Cache-Control: private, max-age=3600ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"X-Request-ID: 7b44ce9a-0940-4cd9-b4c7-b8e924cc6755```## API Implementation### API Route StructureNext.js API routes should follow this structure:```typescript// src/app/api/users/route.tsimport { NextRequest, NextResponse } from 'next/server';import { getServerSession } from 'next-auth';import { authOptions } from '@/lib/auth';import { prisma } from '@/lib/prisma';import { z } from 'zod';// Validation schemaconst userCreateSchema = z.object({  email: z.string().email(),  firstName: z.string().min(1),  lastName: z.string().min(1),  permissions: z.record(z.record(z.boolean())),});export async function GET(request: NextRequest) {  try {    // 1. Authentication    const session = await getServerSession(authOptions);    if (!session) {      return NextResponse.json(        { error: 'Unauthorized', code: 'UNAUTHORIZED' },        { status: 401 }      );    }    // 2. Authorization    if (!session.user.permissions.users.view) {      return NextResponse.json(        { error: 'Insufficient permissions', code: 'FORBIDDEN' },        { status: 403 }      );    }    // 3. Parse query parameters    const { searchParams } = new URL(request.url);    const page = Number(searchParams.get('page') || '1');    const pageSize = Number(searchParams.get('pageSize') || '10');    const search = searchParams.get('search') || undefined;    const showDisabled = searchParams.get('includeDisabled') === 'true';    // 4. Build query    const where: any = {};        // Handle disabled filter    if (!showDisabled) {      where.disabled = false;    }        // Handle search    if (search) {      where.OR = [        { email: { contains: search, mode: 'insensitive' } },        { firstName: { contains: search, mode: 'insensitive' } },        { lastName: { contains: search, mode: 'insensitive' } },      ];    }    // 5. Execute query    const [users, total] = await Promise.all([      prisma.user.findMany({        where,        select: {          id: true,          email: true,          firstName: true,          lastName: true,          disabled: true,          createdAt: true,        },        skip: (page - 1) * pageSize,        take: pageSize,      }),      prisma.user.count({ where }),    ]);    // 6. Return formatted response    return NextResponse.json({      data: users,      meta: {        total,        page,        pageSize,        totalPages: Math.ceil(total / pageSize),      },    });  } catch (error) {    console.error('Error in GET /api/users:', error);    return NextResponse.json(      { error: 'An error occurred while processing your request', code: 'INTERNAL_ERROR' },      { status: 500 }    );  }}export async function POST(request: NextRequest) {  try {    // 1. Authentication    const session = await getServerSession(authOptions);    if (!session) {      return NextResponse.json(        { error: 'Unauthorized', code: 'UNAUTHORIZED' },        { status: 401 }      );    }    // 2. Authorization    if (!session.user.permissions.users.create) {      return NextResponse.json(        { error: 'Insufficient permissions', code: 'FORBIDDEN' },        { status: 403 }      );    }    // 3. Parse and validate request body    const body = await request.json();    const validationResult = userCreateSchema.safeParse(body);        if (!validationResult.success) {      return NextResponse.json(        {           error: 'Validation failed',           code: 'VALIDATION_ERROR',          details: validationResult.error.format()         },        { status: 400 }      );    }    const data = validationResult.data;    // 4. Check for existing user with same email    const existingUser = await prisma.user.findUnique({      where: { email: data.email },    });    if (existingUser) {      return NextResponse.json(        { error: 'User with this email already exists', code: 'CONFLICT' },        { status: 409 }      );    }    // 5. Create user    const user = await prisma.user.create({      data: {        email: data.email,        firstName: data.firstName,        lastName: data.lastName,        permissions: data.permissions,        // Password would be handled separately with hashing      },    });    // 6. Return created user    return NextResponse.json(user, { status: 201 });  } catch (error) {    console.error('Error in POST /api/users:', error);    return NextResponse.json(      { error: 'An error occurred while processing your request', code: 'INTERNAL_ERROR' },      { status: 500 }    );  }}```### Middleware and HandlersUse middleware for common functionality:```typescript// src/middleware/api-middleware.tsimport { NextRequest, NextResponse } from 'next/server';export async function withErrorHandling(  handler: (req: NextRequest) => Promise<NextResponse>,  req: NextRequest) {  try {    return await handler(req);  } catch (error) {    console.error('API Error:', error);        return NextResponse.json(      { error: 'An error occurred while processing your request', code: 'INTERNAL_ERROR' },      { status: 500 }    );  }}export async function withAuth(  handler: (req: NextRequest, session: any) => Promise<NextResponse>,  req: NextRequest) {  const session = await getServerSession(authOptions);    if (!session) {    return NextResponse.json(      { error: 'Unauthorized', code: 'UNAUTHORIZED' },      { status: 401 }    );  }    return handler(req, session);}export async function withValidation(  schema: any,  handler: (req: NextRequest, data: any) => Promise<NextResponse>,  req: NextRequest) {  let body;  try {    body = await req.json();  } catch (error) {    return NextResponse.json(      { error: 'Invalid JSON', code: 'BAD_REQUEST' },      { status: 400 }    );  }    const validationResult = schema.safeParse(body);    if (!validationResult.success) {    return NextResponse.json(      {         error: 'Validation failed',         code: 'VALIDATION_ERROR',        details: validationResult.error.format()       },      { status: 400 }    );  }    return handler(req, validationResult.data);}```Using middleware in route handlers:```typescript// src/app/api/users/[id]/route.tsimport { NextRequest, NextResponse } from 'next/server';import { withErrorHandling, withAuth, withValidation } from '@/middleware/api-middleware';import { prisma } from '@/lib/prisma';import { z } from 'zod';const userUpdateSchema = z.object({  firstName: z.string().min(1).optional(),  lastName: z.string().min(1).optional(),  permissions: z.record(z.record(z.boolean())).optional(),});export async function GET(  request: NextRequest,  { params }: { params: { id: string } }) {  return withErrorHandling(async (req) => {    return withAuth(async (req, session) => {      // Authorization      if (!session.user.permissions.users.view) {        return NextResponse.json(          { error: 'Insufficient permissions', code: 'FORBIDDEN' },          { status: 403 }        );      }            // Get user      const user = await prisma.user.findUnique({        where: { id: params.id },      });            if (!user) {        return NextResponse.json(          { error: `User with ID ${params.id} not found`, code: 'NOT_FOUND' },          { status: 404 }        );      }            return NextResponse.json(user);    }, req);  }, request);}export async function PUT(  request: NextRequest,  { params }: { params: { id: string } }) {  return withErrorHandling(async (req) => {    return withAuth(async (req, session) => {      // Authorization      if (!session.user.permissions.users.edit) {        return NextResponse.json(          { error: 'Insufficient permissions', code: 'FORBIDDEN' },          { status: 403 }        );      }            return withValidation(userUpdateSchema, async (req, data) => {        // Check if user exists        const existingUser = await prisma.user.findUnique({          where: { id: params.id },        });                if (!existingUser) {          return NextResponse.json(            { error: `User with ID ${params.id} not found`, code: 'NOT_FOUND' },            { status: 404 }          );        }                // Update user        const updatedUser = await prisma.user.update({          where: { id: params.id },          data,        });                return NextResponse.json(updatedUser);      }, req);    }, req);  }, request);}```## Authentication and Authorization### AuthenticationAll API routes must implement authentication using NextAuth.js:```typescript// Authentication checkconst session = await getServerSession(authOptions);if (!session) {  return NextResponse.json(    { error: 'Unauthorized', code: 'UNAUTHORIZED' },    { status: 401 }  );}```### AuthorizationImplement fine-grained permission checks:```typescript// Authorization checkif (!session.user.permissions.users.create) {  return NextResponse.json(    { error: 'Insufficient permissions', code: 'FORBIDDEN' },    { status: 403 }  );}```For complex authorization logic, create dedicated helper functions:```typescript// src/lib/auth-helpers.tsexport function canAccessResource(user, resourceType, resourceId, action) {  // Basic permission check  if (!user.permissions[resourceType]?.[action]) {    return false;  }    // Resource-specific checks  if (resourceType === 'customers') {    // If not 'all' permission, check if user is assigned to customer    if (!user.permissions.customers.all) {      return isUserAssignedToCustomer(user.id, resourceId);    }  }    return true;}```## API VersioningFor future API versioning, follow these guidelines:1. **URL-based versioning**:   - `/api/v1/users`   - `/api/v2/users`2. **Version transition**:   - Keep multiple versions supported during transition periods   - Document deprecation timelines   - Provide migration guides## API Documentation### OpenAPI SpecificationDocument all API endpoints using OpenAPI:```yaml# openapi.yamlopenapi: 3.0.0info:  title: GlobalRx API  version: 1.0.0  description: API for the GlobalRx platformpaths:  /api/users:    get:      summary: List users      description: Returns a list of users      parameters:        - name: page          in: query          schema:            type: integer            default: 1          description: Page number        - name: pageSize          in: query          schema:            type: integer            default: 10          description: Number of items per page      responses:        '200':          description: A list of users          content:            application/json:              schema:                type: object                properties:                  data:                    type: array                    items:                      $ref: '#/components/schemas/User'                  meta:                    $ref: '#/components/schemas/PaginationMeta'        '401':          $ref: '#/components/responses/Unauthorized'        '403':          $ref: '#/components/responses/Forbidden'        '500':          $ref: '#/components/responses/InternalError'    post:      summary: Create a user      description: Creates a new user      requestBody:        required: true        content:          application/json:            schema:              $ref: '#/components/schemas/UserCreate'      responses:        '201':          description: Created user          content:            application/json:              schema:                $ref: '#/components/schemas/User'        '400':          $ref: '#/components/responses/ValidationError'        '401':          $ref: '#/components/responses/Unauthorized'        '403':          $ref: '#/components/responses/Forbidden'        '409':          $ref: '#/components/responses/Conflict'        '500':          $ref: '#/components/responses/InternalError'```### API Documentation in CodeUse JSDoc comments to document API routes:```typescript/** * @route GET /api/users * @desc Get a list of users * @access Private - Requires users.view permission * @param {Object} request - The HTTP request * @returns {Object} Response with users data and pagination metadata * @throws {401} Unauthorized - If not authenticated * @throws {403} Forbidden - If missing required permissions * @throws {500} Internal Error - If a server error occurs */export async function GET(request: NextRequest) {  // Implementation...}```## Error Handling and Logging### Error HandlingUse a consistent error handling pattern:```typescripttry {  // API logic} catch (error) {  console.error('Error in API route:', error);    // Determine the appropriate error response  if (error instanceof PrismaClientKnownRequestError) {    // Handle specific Prisma errors    if (error.code === 'P2002') {      return NextResponse.json(        { error: 'Resource already exists', code: 'CONFLICT' },        { status: 409 }      );    }  }    // Default error response  return NextResponse.json(    { error: 'An error occurred while processing your request', code: 'INTERNAL_ERROR' },    { status: 500 }  );}```### Error LoggingLog all errors with context:```typescript// src/lib/logger.tsexport function logApiError(error: any, context: any) {  console.error('API Error:', {    message: error.message,    stack: error.stack,    code: error.code,    context,  });    // In production, send to a logging service  if (process.env.NODE_ENV === 'production') {    // Send to logging service  }}// In API routetry {  // API logic} catch (error) {  logApiError(error, {    route: '/api/users',    method: 'GET',    userId: session?.user?.id,    queryParams: Object.fromEntries(searchParams.entries()),  });    // Return error response}```## Performance Optimization### CachingImplement appropriate caching strategies:```typescript// Cache-Control headers for GET requestsexport async function GET(request: NextRequest) {  // Process request    const response = NextResponse.json(data);    // Set cache headers - adjust values based on data volatility  response.headers.set('Cache-Control', 'private, max-age=60, stale-while-revalidate=300');    return response;}```### Query OptimizationOptimize database queries:```typescript// Efficient query with select and includeconst users = await prisma.user.findMany({  where: {    disabled: false,    // Other filters  },  select: {    id: true,    email: true,    firstName: true,    lastName: true,    // Only select needed fields  },  orderBy: {    createdAt: 'desc',  },  skip: (page - 1) * pageSize,  take: pageSize,});```### Batch OperationsSupport batch operations for efficiency:```typescript// src/app/api/batch/route.tsexport async function POST(request: NextRequest) {  const { operations } = await request.json();    const results = await Promise.all(    operations.map(async (operation) => {      try {        const { type, resource, id, data } = operation;                // Process operation based on type        switch (type) {          case 'create':            // Handle create            break;          case 'update':            // Handle update            break;          case 'delete':            // Handle delete            break;          default:            throw new Error(`Unknown operation type: ${type}`);        }      } catch (error) {        return {          success: false,          error: error.message,        };      }    })  );    return NextResponse.json({ results });}```## API Testing### Unit Testing API HandlersWrite unit tests for API route handlers:```typescript// src/app/api/users/__tests__/route.test.tsimport { NextRequest } from 'next/server';import { GET, POST } from '../route';import { getServerSession } from 'next-auth';import { prisma } from '@/lib/prisma';// Mock dependenciesjest.mock('next-auth', () => ({  getServerSession: jest.fn(),}));jest.mock('@/lib/prisma', () => ({  prisma: {    user: {      findMany: jest.fn(),      count: jest.fn(),      create: jest.fn(),      findUnique: jest.fn(),    },  },}));describe('Users API', () => {  beforeEach(() => {    jest.clearAllMocks();  });    describe('GET /api/users', () => {    it('returns 401 when not authenticated', async () => {      (getServerSession as jest.Mock).mockResolvedValueOnce(null);            const req = new NextRequest('http://localhost:3000/api/users');      const res = await GET(req);            expect(res.status).toBe(401);      const data = await res.json();      expect(data.error).toBe('Unauthorized');    });        it('returns 403 when missing permissions', async () => {      (getServerSession as jest.Mock).mockResolvedValueOnce({        user: {          id: 'user-1',          permissions: {            users: {              view: false,            },          },        },      });            const req = new NextRequest('http://localhost:3000/api/users');      const res = await GET(req);            expect(res.status).toBe(403);      const data = await res.json();      expect(data.error).toBe('Insufficient permissions');    });        it('returns users with pagination', async () => {      // Setup mocks      (getServerSession as jest.Mock).mockResolvedValueOnce({        user: {          id: 'user-1',          permissions: {            users: {              view: true,            },          },        },      });            const mockUsers = [        { id: '1', email: 'user1@example.com' },        { id: '2', email: 'user2@example.com' },      ];            (prisma.user.findMany as jest.Mock).mockResolvedValueOnce(mockUsers);      (prisma.user.count as jest.Mock).mockResolvedValueOnce(10);            const req = new NextRequest('http://localhost:3000/api/users?page=1&pageSize=2');      const res = await GET(req);            expect(res.status).toBe(200);      const data = await res.json();      expect(data.data).toEqual(mockUsers);      expect(data.meta).toEqual({        total: 10,        page: 1,        pageSize: 2,        totalPages: 5,      });    });  });    describe('POST /api/users', () => {    it('validates request body', async () => {      (getServerSession as jest.Mock).mockResolvedValueOnce({        user: {          id: 'user-1',          permissions: {            users: {              create: true,            },          },        },      });            const req = new NextRequest('http://localhost:3000/api/users', {        method: 'POST',        body: JSON.stringify({          // Missing required fields          firstName: 'John',        }),      });            const res = await POST(req);            expect(res.status).toBe(400);      const data = await res.json();      expect(data.error).toBe('Validation failed');      expect(data.details).toBeDefined();    });        it('creates a new user', async () => {      (getServerSession as jest.Mock).mockResolvedValueOnce({        user: {          id: 'user-1',          permissions: {            users: {              create: true,            },          },        },      });            (prisma.user.findUnique as jest.Mock).mockResolvedValueOnce(null);            const mockUser = {        id: 'new-user-id',        email: 'newuser@example.com',        firstName: 'New',        lastName: 'User',        permissions: { users: { view: true } },      };            (prisma.user.create as jest.Mock).mockResolvedValueOnce(mockUser);            const req = new NextRequest('http://localhost:3000/api/users', {        method: 'POST',        body: JSON.stringify({          email: 'newuser@example.com',          firstName: 'New',          lastName: 'User',          permissions: { users: { view: true } },        }),      });            const res = await POST(req);            expect(res.status).toBe(201);      const data = await res.json();      expect(data).toEqual(mockUser);    });  });});```### Integration TestingWrite integration tests that test the API endpoints with the actual database:```typescript// src/integration-tests/api/users.test.tsimport { createUser, getUserById, deleteUser } from '@/test/helpers';import { prisma } from '@/lib/prisma';describe('Users API Integration', () => {  let testUser;  let adminUser;  let token;    beforeAll(async () => {    // Create an admin user for testing    adminUser = await createUser({      email: `admin-${Date.now()}@example.com`,      permissions: {        users: { view: true, create: true, edit: true },      },    });        // Get auth token    token = await getAuthToken(adminUser.email, 'password');  });    afterAll(async () => {    // Clean up test users    await deleteUser(adminUser.id);    if (testUser) {      await deleteUser(testUser.id);    }        await prisma.$disconnect();  });    it('creates and retrieves a user', async () => {    // Create a new user via API    const userData = {      email: `test-${Date.now()}@example.com`,      firstName: 'Test',      lastName: 'User',      permissions: {        users: { view: true },      },    };        const createResponse = await fetch('http://localhost:3000/api/users', {      method: 'POST',      headers: {        'Content-Type': 'application/json',        'Authorization': `Bearer ${token}`,      },      body: JSON.stringify(userData),    });        expect(createResponse.status).toBe(201);    const createdUser = await createResponse.json();        // Save test user ID for cleanup    testUser = createdUser;        // Retrieve the user    const getResponse = await fetch(`http://localhost:3000/api/users/${createdUser.id}`, {      headers: {        'Authorization': `Bearer ${token}`,      },    });        expect(getResponse.status).toBe(200);    const retrievedUser = await getResponse.json();        // Verify user data    expect(retrievedUser.id).toBe(createdUser.id);    expect(retrievedUser.email).toBe(userData.email);    expect(retrievedUser.firstName).toBe(userData.firstName);    expect(retrievedUser.lastName).toBe(userData.lastName);        // Verify permissions    expect(retrievedUser.permissions.users.view).toBe(true);  });});```## API Client UtilitiesCreate utility functions for client-side API calls:```typescript// src/lib/api-client.tsimport { AuthError, ForbiddenError } from '@/lib/errors';interface FetchOptions extends RequestInit {  params?: Record<string, string | number | boolean | undefined>;}export async function apiFetch<T>(  endpoint: string,  options: FetchOptions = {}): Promise<T> {  const { params, ...fetchOptions } = options;    // Build URL with query parameters  const url = new URL(`/api/${endpoint}`, window.location.origin);    if (params) {    Object.entries(params).forEach(([key, value]) => {      if (value !== undefined) {        url.searchParams.append(key, String(value));      }    });  }    // Set default headers  const headers = new Headers(fetchOptions.headers);    if (!headers.has('Content-Type') && fetchOptions.method !== 'GET' && fetchOptions.body) {    headers.set('Content-Type', 'application/json');  }    // Make the request  const response = await fetch(url.toString(), {    ...fetchOptions,    headers,  });    // Handle auth errors  if (response.status === 401) {    throw new AuthError('Authentication required');  }    if (response.status === 403) {    throw new ForbiddenError('Insufficient permissions');  }    // Parse the response  const data = await response.json();    // Handle application errors  if (!response.ok) {    throw new Error(data.error || 'An error occurred');  }    return data as T;}// Helper methods for common operationsexport const api = {  get: <T>(endpoint: string, params?: Record<string, any>) =>     apiFetch<T>(endpoint, { params }),    post: <T>(endpoint: string, data: any) =>     apiFetch<T>(endpoint, { method: 'POST', body: JSON.stringify(data) }),    put: <T>(endpoint: string, data: any) =>     apiFetch<T>(endpoint, { method: 'PUT', body: JSON.stringify(data) }),    patch: <T>(endpoint: string, data: any) =>     apiFetch<T>(endpoint, { method: 'PATCH', body: JSON.stringify(data) }),    delete: <T>(endpoint: string) =>     apiFetch<T>(endpoint, { method: 'DELETE' }),};```## API Best Practices### Security Best Practices1. **Input Validation**: Validate all inputs using Zod or similar2. **Output Sanitization**: Avoid exposing sensitive data3. **Rate Limiting**: Implement rate limiting for public endpoints4. **CSRF Protection**: Use CSRF tokens for state-changing operations5. **Security Headers**: Set appropriate security headers### Performance Best Practices1. **Select Only Needed Fields**: Avoid overfetching data2. **Use Pagination**: Always paginate list endpoints3. **Optimize Database Queries**: Use appropriate indexes4. **Caching**: Implement caching where appropriate5. **Compression**: Use compression for responses### Maintainability Best Practices1. **Consistent Patterns**: Follow the same patterns across all endpoints2. **Separation of Concerns**: Separate validation, business logic, and data access3. **Error Handling**: Implement comprehensive error handling4. **Documentation**: Document all endpoints thoroughly5. **Testing**: Write tests for all endpoints# State Management# State Management## State Management ApproachThe GlobalRx application uses a combination of state management approaches based on the specific needs of different features and components. Rather than relying on a single global state management solution, the application adopts a pragmatic approach that leverages React's built-in capabilities and context API for most state management needs.### Types of StateThe application manages different types of state:1. **Local Component State**: State that belongs to a single component2. **Shared State**: State that is shared between multiple components3. **Server State**: Data fetched from the API4. **URL State**: State stored in the URL (query parameters, route parameters)5. **Form State**: State for form inputs and validation6. **Authentication State**: User authentication information7. **Global UI State**: UI state used across the application## Local Component State### Using useStateFor simple component state, use React's `useState` hook:```tsximport { useState } from 'react';function Counter() {  const [count, setCount] = useState(0);    return (    <div>      <p>Count: {count}</p>      <button onClick={() => setCount(count + 1)}>Increment</button>      <button onClick={() => setCount(count - 1)}>Decrement</button>    </div>  );}```### Using useReducerFor more complex state logic, use `useReducer`:```tsximport { useReducer } from 'react';// Define state shapeinterface CounterState {  count: number;  lastOperation: 'increment' | 'decrement' | 'reset' | null;  history: number[];}// Define actionstype CounterAction =   | { type: 'INCREMENT'; payload?: number }  | { type: 'DECREMENT'; payload?: number }  | { type: 'RESET' };// Initial stateconst initialState: CounterState = {  count: 0,  lastOperation: null,  history: [],};// Reducer functionfunction counterReducer(state: CounterState, action: CounterAction): CounterState {  switch (action.type) {    case 'INCREMENT':      const incrementBy = action.payload || 1;      return {        count: state.count + incrementBy,        lastOperation: 'increment',        history: [...state.history, state.count + incrementBy],      };    case 'DECREMENT':      const decrementBy = action.payload || 1;      return {        count: state.count - decrementBy,        lastOperation: 'decrement',        history: [...state.history, state.count - decrementBy],      };    case 'RESET':      return {        count: 0,        lastOperation: 'reset',        history: [...state.history, 0],      };    default:      return state;  }}function ComplexCounter() {  const [state, dispatch] = useReducer(counterReducer, initialState);    return (    <div>      <p>Count: {state.count}</p>      <p>Last Operation: {state.lastOperation || 'None'}</p>      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+1</button>      <button onClick={() => dispatch({ type: 'INCREMENT', payload: 5 })}>+5</button>      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-1</button>      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>      <div>        <h3>History</h3>        <ul>          {state.history.map((value, index) => (            <li key={index}>{value}</li>          ))}        </ul>      </div>    </div>  );}```## Shared State with Context### Creating a ContextUse React Context for state that needs to be shared between components:```tsx// src/contexts/ThemeContext.tsximport React, { createContext, useContext, useState, useEffect } from 'react';// Define the shape of the contexttype Theme = 'light' | 'dark';interface ThemeContextType {  theme: Theme;  setTheme: (theme: Theme) => void;  toggleTheme: () => void;}// Create context with a default valueconst ThemeContext = createContext<ThemeContextType>({  theme: 'light',  setTheme: () => {},  toggleTheme: () => {},});// Create a provider componentexport function ThemeProvider({ children }: { children: React.ReactNode }) {  const [theme, setTheme] = useState<Theme>('light');    // Load theme from localStorage on initial render  useEffect(() => {    const savedTheme = localStorage.getItem('theme') as Theme;    if (savedTheme) {      setTheme(savedTheme);    }  }, []);    // Save theme to localStorage when it changes  useEffect(() => {    localStorage.setItem('theme', theme);    // Apply theme to document body    document.body.className = theme === 'dark' ? 'dark' : 'light';  }, [theme]);    // Toggle theme function  const toggleTheme = () => {    setTheme(prev => prev === 'light' ? 'dark' : 'light');  };    return (    <ThemeContext.Provider value={{ theme, setTheme, toggleTheme }}>      {children}    </ThemeContext.Provider>  );}// Create a custom hook for using the theme contextexport function useTheme() {  const context = useContext(ThemeContext);    if (context === undefined) {    throw new Error('useTheme must be used within a ThemeProvider');  }    return context;}```### Using the Context```tsx// src/components/layout/theme-toggle.tsximport { useTheme } from '@/contexts/ThemeContext';import { Sun, Moon } from 'lucide-react';import { Button } from '@/components/ui/button';export function ThemeToggle() {  const { theme, toggleTheme } = useTheme();    return (    <Button      variant="ghost"      size="sm"      onClick={toggleTheme}      aria-label={`Switch to ${theme === 'light' ? 'dark' : 'light'} theme`}    >      {theme === 'light' ? <Moon size={16} /> : <Sun size={16} />}    </Button>  );}// In your layoutimport { ThemeProvider } from '@/contexts/ThemeContext';import { ThemeToggle } from '@/components/layout/theme-toggle';export default function Layout({ children }) {  return (    <ThemeProvider>      <div>        <header>          <nav>            {/* Other navigation items */}            <ThemeToggle />          </nav>        </header>        <main>{children}</main>      </div>    </ThemeProvider>  );}```### Context Best Practices1. **Split Contexts by Domain**: Create separate contexts for different domains (auth, UI, features)2. **Performance Optimization**: Use context splitting and memoization to avoid unnecessary re-renders3. **Default Values**: Always provide meaningful default values for contexts4. **Type Safety**: Use TypeScript for type-safe context usage5. **Custom Hooks**: Create custom hooks for accessing context values## Server State Management### Using SWRFor managing server state, use SWR (Stale-While-Revalidate):```tsx// src/hooks/useUsers.tsimport useSWR from 'swr';import { api } from '@/lib/api-client';export interface User {  id: string;  email: string;  firstName?: string;  lastName?: string;  disabled: boolean;}interface UsersResponse {  data: User[];  meta: {    total: number;    page: number;    pageSize: number;    totalPages: number;  };}export function useUsers(page = 1, pageSize = 10, search?: string) {  const { data, error, isLoading, mutate } = useSWR<UsersResponse>(    ['users', page, pageSize, search],    () => api.get('users', { page, pageSize, search })  );    return {    users: data?.data || [],    meta: data?.meta,    isLoading,    error,    mutate,  };}// Using the hook in a componentimport { useUsers } from '@/hooks/useUsers';function UserList() {  const [page, setPage] = useState(1);  const [search, setSearch] = useState('');    const { users, meta, isLoading, error, mutate } = useUsers(page, 10, search);    if (isLoading) return <div>Loading...</div>;  if (error) return <div>Error: {error.message}</div>;    return (    <div>      <div>        <input          type="text"          value={search}          onChange={(e) => setSearch(e.target.value)}          placeholder="Search users..."        />      </div>            <table>        <thead>          <tr>            <th>Email</th>            <th>Name</th>            <th>Status</th>          </tr>        </thead>        <tbody>          {users.map((user) => (            <tr key={user.id}>              <td>{user.email}</td>              <td>{user.firstName} {user.lastName}</td>              <td>{user.disabled ? 'Disabled' : 'Active'}</td>            </tr>          ))}        </tbody>      </table>            <div>        <button           onClick={() => setPage((p) => Math.max(p - 1, 1))}          disabled={page === 1}        >          Previous        </button>        <span>Page {page} of {meta?.totalPages || 1}</span>        <button           onClick={() => setPage((p) => p + 1)}          disabled={page >= (meta?.totalPages || 1)}        >          Next        </button>      </div>    </div>  );}```### Custom Fetch Wrapper with SWRCreate a standardized way to interact with your API:```tsx// src/lib/api-hooks.tsimport useSWR, { SWRConfiguration, SWRResponse } from 'swr';import { api } from '@/lib/api-client';export function useApiResource<T>(  resource: string,  id?: string,  config?: SWRConfiguration): SWRResponse<T, Error> {  const endpoint = id ? `${resource}/${id}` : resource;    return useSWR<T, Error>(    endpoint ? [endpoint] : null,    () => api.get(endpoint),    config  );}export function useApiCollection<T>(  resource: string,  params?: Record<string, any>,  config?: SWRConfiguration): SWRResponse<{ data: T[]; meta: any }, Error> {  return useSWR<{ data: T[]; meta: any }, Error>(    resource ? [resource, params] : null,    () => api.get(resource, params),    config  );}// Usageconst { data: user, error, isLoading } = useApiResource<User>('users', userId);const { data, error, isLoading } = useApiCollection<User>('users', { page, pageSize });```### MutationHandle mutations (create, update, delete) with SWR:```tsx// src/hooks/useUserMutations.tsimport { useState } from 'react';import { api } from '@/lib/api-client';import { User } from '@/types/user';export function useUserMutations() {  const [isLoading, setIsLoading] = useState(false);  const [error, setError] = useState<Error | null>(null);    const createUser = async (userData: Omit<User, 'id'>): Promise<User> => {    setIsLoading(true);    setError(null);        try {      const user = await api.post<User>('users', userData);      return user;    } catch (err) {      setError(err instanceof Error ? err : new Error(String(err)));      throw err;    } finally {      setIsLoading(false);    }  };    const updateUser = async (id: string, userData: Partial<User>): Promise<User> => {    setIsLoading(true);    setError(null);        try {      const user = await api.put<User>(`users/${id}`, userData);      return user;    } catch (err) {      setError(err instanceof Error ? err : new Error(String(err)));      throw err;    } finally {      setIsLoading(false);    }  };    const deleteUser = async (id: string): Promise<void> => {    setIsLoading(true);    setError(null);        try {      await api.delete(`users/${id}`);    } catch (err) {      setError(err instanceof Error ? err : new Error(String(err)));      throw err;    } finally {      setIsLoading(false);    }  };    return {    createUser,    updateUser,    deleteUser,    isLoading,    error,  };}// Using mutations in a componentimport { useUsers } from '@/hooks/useUsers';import { useUserMutations } from '@/hooks/useUserMutations';function UserAdmin() {  const { users, mutate } = useUsers();  const { deleteUser, isLoading, error } = useUserMutations();    const handleDelete = async (id: string) => {    try {      await deleteUser(id);      // Update the users list after successful deletion      mutate();    } catch (err) {      console.error('Failed to delete user:', err);    }  };    return (    <div>      {error && <div className="error">{error.message}</div>}      <table>        <tbody>          {users.map((user) => (            <tr key={user.id}>              <td>{user.email}</td>              <td>                <button                   onClick={() => handleDelete(user.id)}                  disabled={isLoading}                >                  Delete                </button>              </td>            </tr>          ))}        </tbody>      </table>    </div>  );}```## URL State### Using Next.js RouterStore state in the URL for shareable and bookmarkable state:```tsx// src/components/filter-table.tsx'use client';import { usePathname, useRouter, useSearchParams } from 'next/navigation';import { useCallback } from 'react';export function FilterTable() {  const router = useRouter();  const pathname = usePathname();  const searchParams = useSearchParams();    // Get current values from URL  const currentPage = Number(searchParams.get('page') || '1');  const currentPageSize = Number(searchParams.get('pageSize') || '10');  const currentSort = searchParams.get('sort') || 'name';  const currentFilter = searchParams.get('filter') || '';    // Update URL with new search params  const createQueryString = useCallback(    (params: Record<string, string | number | null>) => {      const newSearchParams = new URLSearchParams(searchParams.toString());            // Update or delete each parameter      Object.entries(params).forEach(([key, value]) => {        if (value === null) {          newSearchParams.delete(key);        } else {          newSearchParams.set(key, String(value));        }      });            return newSearchParams.toString();    },    [searchParams]  );    // Handle page change  const handlePageChange = (newPage: number) => {    router.push(`${pathname}?${createQueryString({ page: newPage })}`);  };    // Handle sort change  const handleSortChange = (field: string) => {    // Toggle sort direction if same field    const newSort = currentSort === field ? `-${field}` : field;    router.push(`${pathname}?${createQueryString({ sort: newSort, page: 1 })}`);  };    // Handle filter change  const handleFilterChange = (filter: string) => {    router.push(`${pathname}?${createQueryString({ filter, page: 1 })}`);  };    return (    <div>      <div>        <input          type="text"          value={currentFilter}          onChange={(e) => handleFilterChange(e.target.value)}          placeholder="Filter items..."        />      </div>            <table>        <thead>          <tr>            <th onClick={() => handleSortChange('name')}>              Name {currentSort === 'name' ? '?' : currentSort === '-name' ? '?' : ''}            </th>            <th onClick={() => handleSortChange('category')}>              Category {currentSort === 'category' ? '?' : currentSort === '-category' ? '?' : ''}            </th>            <th onClick={() => handleSortChange('createdAt')}>              Created {currentSort === 'createdAt' ? '?' : currentSort === '-createdAt' ? '?' : ''}            </th>          </tr>        </thead>        <tbody>          {/* Table rows here */}        </tbody>      </table>            <div>        <button           onClick={() => handlePageChange(currentPage - 1)}          disabled={currentPage === 1}        >          Previous        </button>        <span>Page {currentPage}</span>        <button           onClick={() => handlePageChange(currentPage + 1)}        >          Next        </button>      </div>    </div>  );}```## Form State### Using React Hook FormUse React Hook Form with Zod for form state management:```tsx// src/components/modules/user-admin/user-form.tsx'use client';import { useForm } from 'react-hook-form';import { zodResolver } from '@hookform/resolvers/zod';import * as z from 'zod';import { FormTable, FormRow, FormActions } from '@/components/ui/form';import { Input } from '@/components/ui/input';import { Button } from '@/components/ui/button';import { Checkbox } from '@/components/ui/checkbox';// Define validation schema with Zodconst userFormSchema = z.object({  email: z.string().email('Invalid email address'),  firstName: z.string().min(1, 'First name is required'),  lastName: z.string().min(1, 'Last name is required'),  permissions: z.object({    users: z.object({      view: z.boolean(),      create: z.boolean(),      edit: z.boolean(),    }),    countries: z.object({      view: z.boolean(),      manage: z.boolean(),    }),  }),});// Infer TypeScript type from Zod schematype UserFormValues = z.infer<typeof userFormSchema>;interface UserFormProps {  initialData?: Partial<UserFormValues>;  onSubmit: (data: UserFormValues) => void;  onCancel: () => void;  isSubmitting?: boolean;}export function UserForm({  initialData,  onSubmit,  onCancel,  isSubmitting = false,}: UserFormProps) {  const {    register,    handleSubmit,    formState: { errors, isValid },    reset,    setValue,    watch,  } = useForm<UserFormValues>({    resolver: zodResolver(userFormSchema),    defaultValues: initialData || {      email: '',      firstName: '',      lastName: '',      permissions: {        users: {          view: false,          create: false,          edit: false,        },        countries: {          view: false,          manage: false,        },      },    },  });    // Watch permission values  const userViewPermission = watch('permissions.users.view');    return (    <form onSubmit={handleSubmit(onSubmit)}>      <FormTable>        <FormRow          label="Email"          htmlFor="email"          required={true}          error={errors.email?.message}        >          <Input            id="email"            {...register('email')}          />        </FormRow>                <FormRow          label="First Name"          htmlFor="firstName"          required={true}          error={errors.firstName?.message}        >          <Input            id="firstName"            {...register('firstName')}          />        </FormRow>                <FormRow          label="Last Name"          htmlFor="lastName"          required={true}          error={errors.lastName?.message}        >          <Input            id="lastName"            {...register('lastName')}          />        </FormRow>                <tr>          <td colSpan={3} className="pt-6 pb-2">            <h3 className="text-lg font-semibold">Permissions</h3>          </td>        </tr>                <FormRow          label="User Permissions"          htmlFor="permissions-users-view"        >          <div className="space-y-2">            <div className="flex items-center space-x-2">              <Checkbox                id="permissions-users-view"                checked={userViewPermission}                onCheckedChange={(checked) =>                   setValue('permissions.users.view', checked as boolean, { shouldValidate: true })                }              />              <label htmlFor="permissions-users-view">View Users</label>            </div>                        <div className="flex items-center space-x-2">              <Checkbox                id="permissions-users-create"                checked={watch('permissions.users.create')}                onCheckedChange={(checked) =>                   setValue('permissions.users.create', checked as boolean, { shouldValidate: true })                }                disabled={!userViewPermission} // Can't create if can't view              />              <label htmlFor="permissions-users-create">Create Users</label>            </div>                        <div className="flex items-center space-x-2">              <Checkbox                id="permissions-users-edit"                checked={watch('permissions.users.edit')}                onCheckedChange={(checked) =>                   setValue('permissions.users.edit', checked as boolean, { shouldValidate: true })                }                disabled={!userViewPermission} // Can't edit if can't view              />              <label htmlFor="permissions-users-edit">Edit Users</label>            </div>          </div>        </FormRow>                <FormRow          label="Country Permissions"          htmlFor="permissions-countries-view"        >          <div className="space-y-2">            <div className="flex items-center space-x-2">              <Checkbox                id="permissions-countries-view"                checked={watch('permissions.countries.view')}                onCheckedChange={(checked) =>                   setValue('permissions.countries.view', checked as boolean, { shouldValidate: true })                }              />              <label htmlFor="permissions-countries-view">View Countries</label>            </div>                        <div className="flex items-center space-x-2">              <Checkbox                id="permissions-countries-manage"                checked={watch('permissions.countries.manage')}                onCheckedChange={(checked) =>                   setValue('permissions.countries.manage', checked as boolean, { shouldValidate: true })                }                disabled={!watch('permissions.countries.view')} // Can't manage if can't view              />              <label htmlFor="permissions-countries-manage">Manage Countries</label>            </div>          </div>        </FormRow>      </FormTable>            <FormActions>        <Button          type="button"          variant="outline"          onClick={onCancel}          disabled={isSubmitting}        >          Cancel        </Button>        <Button          type="submit"          disabled={!isValid || isSubmitting}        >          {isSubmitting ? 'Saving...' : 'Save User'}        </Button>      </FormActions>    </form>  );}```## Authentication State### Auth ContextHandle authentication state with a dedicated context:```tsx// src/contexts/AuthContext.tsximport { createContext, useContext, useState, useEffect } from 'react';import { useRouter } from 'next/navigation';import { User } from '@/types/user';interface AuthContextType {  user: User | null;  isAuthenticated: boolean;  isLoading: boolean;  login: (email: string, password: string) => Promise<boolean>;  logout: () => Promise<void>;  checkPermission: (resource: string, action: string) => boolean;  fetchWithAuth: (url: string, options?: RequestInit) => Promise<Response>;}const AuthContext = createContext<AuthContextType>({  user: null,  isAuthenticated: false,  isLoading: true,  login: async () => false,  logout: async () => {},  checkPermission: () => false,  fetchWithAuth: async () => new Response(),});export function AuthProvider({ children }: { children: React.ReactNode }) {  const [user, setUser] = useState<User | null>(null);  const [isLoading, setIsLoading] = useState(true);  const router = useRouter();    // Check authentication status on initial load  useEffect(() => {    const checkAuth = async () => {      try {        const response = await fetch('/api/auth/session');        if (response.ok) {          const data = await response.json();          if (data.user) {            setUser(data.user);          } else {            setUser(null);          }        } else {          setUser(null);        }      } catch (error) {        console.error('Auth check error:', error);        setUser(null);      } finally {        setIsLoading(false);      }    };        checkAuth();  }, []);    // Login function  const login = async (email: string, password: string): Promise<boolean> => {    try {      setIsLoading(true);            const response = await fetch('/api/auth/login', {        method: 'POST',        headers: {          'Content-Type': 'application/json',        },        body: JSON.stringify({ email, password }),      });            if (!response.ok) {        return false;      }            const data = await response.json();      setUser(data.user);            return true;    } catch (error) {      console.error('Login error:', error);      return false;    } finally {      setIsLoading(false);    }  };    // Logout function  const logout = async (): Promise<void> => {    try {      setIsLoading(true);            await fetch('/api/auth/logout', {        method: 'POST',      });            setUser(null);      router.push('/login');    } catch (error) {      console.error('Logout error:', error);    } finally {      setIsLoading(false);    }  };    // Check if user has a specific permission  const checkPermission = (resource: string, action: string): boolean => {    if (!user) return false;        return !!user.permissions?.[resource]?.[action];  };    // Fetch with authentication  const fetchWithAuth = async (url: string, options: RequestInit = {}): Promise<Response> => {    try {      const response = await fetch(url, {        ...options,        headers: {          ...(options.headers || {}),          'Content-Type': 'application/json',        },      });            // Handle unauthorized responses      if (response.status === 401) {        // Session expired, redirect to login        setUser(null);        router.push(`/login?returnUrl=${encodeURIComponent(window.location.pathname)}`);      }            return response;    } catch (error) {      console.error('API request error:', error);      throw error;    }  };    return (    <AuthContext.Provider      value={{        user,        isAuthenticated: !!user,        isLoading,        login,        logout,        checkPermission,        fetchWithAuth,      }}    >      {children}    </AuthContext.Provider>  );}export function useAuth() {  return useContext(AuthContext);}```## Global UI State### UI ContextManage global UI state with a dedicated context:```tsx// src/contexts/UIContext.tsximport { createContext, useContext, useState, ReactNode } from 'react';interface Notification {  id: string;  type: 'info' | 'success' | 'warning' | 'error';  message: string;  duration?: number;}interface UIContextType {  notifications: Notification[];  addNotification: (notification: Omit<Notification, 'id'>) => void;  removeNotification: (id: string) => void;  isSidebarOpen: boolean;  toggleSidebar: () => void;  setSidebarOpen: (open: boolean) => void;}const UIContext = createContext<UIContextType>({  notifications: [],  addNotification: () => {},  removeNotification: () => {},  isSidebarOpen: false,  toggleSidebar: () => {},  setSidebarOpen: () => {},});export function UIProvider({ children }: { children: ReactNode }) {  const [notifications, setNotifications] = useState<Notification[]>([]);  const [isSidebarOpen, setIsSidebarOpen] = useState(false);    const addNotification = (notification: Omit<Notification, 'id'>) => {    const id = Math.random().toString(36).substring(2, 11);    const newNotification = { ...notification, id };        setNotifications((prev) => [...prev, newNotification]);        // Auto-remove notifications after duration    if (notification.duration !== 0) {      const duration = notification.duration || 5000; // Default 5 seconds      setTimeout(() => {        removeNotification(id);      }, duration);    }  };    const removeNotification = (id: string) => {    setNotifications((prev) => prev.filter((notification) => notification.id !== id));  };    const toggleSidebar = () => {    setIsSidebarOpen((prev) => !prev);  };    return (    <UIContext.Provider      value={{        notifications,        addNotification,        removeNotification,        isSidebarOpen,        toggleSidebar,        setSidebarOpen: setIsSidebarOpen,      }}    >      {children}    </UIContext.Provider>  );}export function useUI() {  return useContext(UIContext);}```## Complex State Management### Combined ApproachFor more complex features, combine the above approaches:```tsx// src/components/modules/data-explorer/data-explorer.tsx'use client';import { useState, useMemo } from 'react';import { useRouter, usePathname, useSearchParams } from 'next/navigation';import { useAuth } from '@/contexts/AuthContext';import { useUI } from '@/contexts/UIContext';import { useApiCollection } from '@/lib/api-hooks';import DataTable from './data-table';import FilterPanel from './filter-panel';import Pagination from './pagination';export default function DataExplorer() {  const router = useRouter();  const pathname = usePathname();  const searchParams = useSearchParams();  const { checkPermission, fetchWithAuth } = useAuth();  const { addNotification } = useUI();    // Get current values from URL  const page = Number(searchParams.get('page') || '1');  const pageSize = Number(searchParams.get('pageSize') || '10');  const sortField = searchParams.get('sort') || 'createdAt';  const sortDirection = sortField.startsWith('-') ? 'desc' : 'asc';  const searchTerm = searchParams.get('search') || '';  const filterField = searchParams.get('filterField') || '';  const filterValue = searchParams.get('filterValue') || '';    // Local state for selected items  const [selectedItems, setSelectedItems] = useState<string[]>([]);    // Fetch data  const { data, error, isLoading, mutate } = useApiCollection(    'data-items',    {      page,      pageSize,      sort: sortField,      search: searchTerm,      ...(filterField && filterValue ? { [filterField]: filterValue } : {}),    }  );    // Computed values  const sortBy = useMemo(() => {    return sortField.startsWith('-') ? sortField.substring(1) : sortField;  }, [sortField]);    // URL update helper  const updateUrl = (params: Record<string, string | number | null>) => {    const newParams = new URLSearchParams(searchParams.toString());        Object.entries(params).forEach(([key, value]) => {      if (value === null) {        newParams.delete(key);      } else {        newParams.set(key, String(value));      }    });        router.push(`${pathname}?${newParams.toString()}`);  };    // Handlers  const handlePageChange = (newPage: number) => {    updateUrl({ page: newPage });  };    const handleSortChange = (field: string) => {    const newSort = field === sortBy && !sortField.startsWith('-')       ? `-${field}`       : field;        updateUrl({ sort: newSort, page: 1 });  };    const handleSearch = (term: string) => {    updateUrl({ search: term || null, page: 1 });  };    const handleFilter = (field: string, value: string) => {    updateUrl({       filterField: field || null,       filterValue: value || null,       page: 1     });  };    const handleSelectionChange = (items: string[]) => {    setSelectedItems(items);  };    const handleBulkAction = async (action: string) => {    if (selectedItems.length === 0) {      addNotification({        type: 'warning',        message: 'No items selected',      });      return;    }        try {      const response = await fetchWithAuth('/api/data-items/bulk-action', {        method: 'POST',        body: JSON.stringify({          action,          ids: selectedItems,        }),      });            if (!response.ok) {        throw new Error('Failed to perform bulk action');      }            addNotification({        type: 'success',        message: `Successfully performed ${action} on ${selectedItems.length} items`,      });            // Reset selection and refresh data      setSelectedItems([]);      mutate();    } catch (err) {      console.error('Bulk action error:', err);      addNotification({        type: 'error',        message: `Failed to perform ${action}: ${err instanceof Error ? err.message : String(err)}`,      });    }  };    // Check permissions  const canEdit = checkPermission('data', 'edit');  const canDelete = checkPermission('data', 'delete');    if (error) {    return (      <div className="p-4 bg-red-50 text-red-800 rounded">        Error loading data: {error instanceof Error ? error.message : String(error)}      </div>    );  }    return (    <div className="space-y-4">      <FilterPanel         searchTerm={searchTerm}        onSearch={handleSearch}        filterField={filterField}        filterValue={filterValue}        onFilter={handleFilter}      />            <DataTable        data={data?.data || []}        isLoading={isLoading}        sortField={sortBy}        sortDirection={sortDirection}        onSort={handleSortChange}        selectedItems={selectedItems}        onSelectionChange={handleSelectionChange}        canEdit={canEdit}        canDelete={canDelete}      />            <Pagination        currentPage={page}        pageSize={pageSize}        totalItems={data?.meta?.total || 0}        onPageChange={handlePageChange}      />            {(canEdit || canDelete) && selectedItems.length > 0 && (        <div className="fixed bottom-4 right-4 bg-white p-4 shadow-lg rounded-lg">          <div className="text-sm font-medium mb-2">            {selectedItems.length} items selected          </div>          <div className="flex space-x-2">            {canEdit && (              <Button                size="sm"                onClick={() => handleBulkAction('edit')}              >                Edit Selected              </Button>            )}            {canDelete && (              <Button                size="sm"                variant="destructive"                onClick={() => handleBulkAction('delete')}              >                Delete Selected              </Button>            )}          </div>        </div>      )}    </div>  );}```## State Management Guidelines### When to Use Each Approach1. **Local State (useState/useReducer)**:   - Component-specific UI state   - Simple form state   - Temporary data that doesn't need to be shared2. **Context API**:   - State shared across multiple components   - Theme settings   - User preferences   - Authentication state   - Global UI state3. **SWR/React Query**:   - Remote data fetching   - Caching and synchronization   - Optimistic updates   - Automatic refetching4. **URL State**:   - Filterable/sortable tables   - Tab selections   - Paginated content   - Search queries   - Any state that should be shareable/bookmarkable5. **Form Libraries**:   - Complex forms   - Form validation   - Wizard-style multi-step forms   - Dynamic forms### Performance Considerations1. **Avoid Unnecessary Re-renders**:   - Use memoization (useMemo, useCallback, React.memo)   - Split contexts to avoid rendering unrelated components2. **Optimize Context Performance**:   ```tsx   // Split context value   const [state, dispatch] = useReducer(reducer, initialState);      // Memoize context value   const contextValue = useMemo(() => {     return { state, dispatch };   }, [state]);      return (     <AppContext.Provider value={contextValue}>       {children}     </AppContext.Provider>   );   ```3. **Batch Updates**:   ```tsx   // Instead of multiple state updates   setLoading(true);   setData(result);   setError(null);   setLoading(false);      // Use useReducer   dispatch({ type: 'FETCH_SUCCESS', payload: result });   ```### Best Practices1. **Keep State as Local as Possible**: Don't use global state when component state is sufficient2. **Use Immutable Updates**: Never mutate state directly3. **State Colocation**: Keep state close to where it's used4. **Single Source of Truth**: Avoid duplicating state5. **Separate UI from Business Logic**: Use custom hooks to encapsulate business logic6. **Predictable State Updates**: Use reducers for complex state logic7. **Type Safety**: Use TypeScript for type safety8. **Debugging**: Use React DevTools for debugging state